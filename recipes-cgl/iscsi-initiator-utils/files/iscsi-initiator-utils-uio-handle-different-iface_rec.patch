diff -Naurp open-iscsi-2.0-872-rc4-bnx2i.base/iscsiuio/include/config.h open-iscsi-2.0-872-rc4-bnx2i.build2/iscsiuio/include/config.h
--- open-iscsi-2.0-872-rc4-bnx2i.base/iscsiuio/include/config.h	2011-08-14 22:58:02.000000000 -0500
+++ open-iscsi-2.0-872-rc4-bnx2i.build2/iscsiuio/include/config.h	2011-08-15 00:05:23.000000000 -0500
@@ -22,6 +22,7 @@
 
 #include <netdb.h>
 #include "list.h"
+#include "iscsi_net_util.h"
 
 /* ISIDs now have a typed naming authority in them.  We use an OUI */
 #define DRIVER_ISID_0  0x00
@@ -31,18 +32,33 @@
 /* max len of interface */
 #define ISCSI_MAX_IFACE_LEN	65
 
-#if (ISCSID_VERSION == 872) /* 2.0-872 (RHEL 6.0) */
-
 #define ISCSI_HWADDRESS_BUF_SIZE 18
 #define ISCSI_TRANSPORT_NAME_MAXLEN 16
+#define ISCSI_MAX_STR_LEN 80
 
 typedef struct iface_rec {
 	struct list_head	list;
 	/* iscsi iface record name */
 	char			name[ISCSI_MAX_IFACE_LEN];
+	uint32_t		iface_num;
 	/* network layer iface name (eth0) */
 	char			netdev[IFNAMSIZ];
 	char			ipaddress[NI_MAXHOST];
+	char			subnet_mask[NI_MAXHOST];
+	char			gateway[NI_MAXHOST];
+	char			bootproto[ISCSI_MAX_STR_LEN];
+	char			ipv6_linklocal[NI_MAXHOST];
+	char			ipv6_router[NI_MAXHOST];
+	char			ipv6_autocfg[NI_MAXHOST];
+	char			linklocal_autocfg[NI_MAXHOST];
+	char			router_autocfg[NI_MAXHOST];
+	uint16_t		vlan_id;
+	uint8_t			vlan_priority;
+	char			vlan_state[ISCSI_MAX_STR_LEN];
+	char			state[ISCSI_MAX_STR_LEN]; /* 0 = disable,
+							   * 1 = enable */
+	uint16_t		mtu;
+	uint16_t		port;
 	/*
 	 * TODO: we may have to make this bigger and interconnect
 	 * specific for infinniband 
@@ -55,40 +71,6 @@ typedef struct iface_rec {
 	 */
 	char			alias[TARGET_NAME_MAXLEN + 1];
 	char			iname[TARGET_NAME_MAXLEN + 1];
-
-	char			vlan[ISCSI_MAX_IFACE_LEN];
-} iface_rec_t;
-
-#else /* 2.0-871 (RHEL 5.5)  */
-/* number of possible connections per session */
-#define ISCSI_CONN_MAX		1
-
-#define ISCSI_TRANSPORT_NAME_MAXLEN 16
-
-typedef struct iface_rec {
-	struct list_head	list;
-	/* iscsi iface record name */
-	char			name[ISCSI_MAX_IFACE_LEN];
-	/* network layer iface name (eth0) */
-	char			netdev[IFNAMSIZ];
-	char			ipaddress[NI_MAXHOST];
-
-	/*
-	 * TODO: we may have to make this bigger and interconnect
-	 * specific for infinniband 
-	 */
-	char			hwaddress[ISCSI_MAX_IFACE_LEN];
-	char			transport_name[ISCSI_TRANSPORT_NAME_MAXLEN];
-	/*
-	 * This is only used for boot now, but the iser guys
-	 * can use this for their virtualization idea.
-	 */
-	char			alias[TARGET_NAME_MAXLEN + 1];
-	char			iname[TARGET_NAME_MAXLEN + 1];
-
-	char			vlan[ISCSI_MAX_IFACE_LEN];
 } iface_rec_t;
 
-#endif /* ISCSID_VERSION */
-
 #endif /* CONFIG_H */
diff -Naurp open-iscsi-2.0-872-rc4-bnx2i.base/iscsiuio/include/iscsi_net_util.h open-iscsi-2.0-872-rc4-bnx2i.build2/iscsiuio/include/iscsi_net_util.h
--- open-iscsi-2.0-872-rc4-bnx2i.base/iscsiuio/include/iscsi_net_util.h	1969-12-31 18:00:00.000000000 -0600
+++ open-iscsi-2.0-872-rc4-bnx2i.build2/iscsiuio/include/iscsi_net_util.h	2011-08-14 23:20:09.000000000 -0500
@@ -0,0 +1,11 @@
+#ifndef __ISCSI_NET_UTIL_h__
+#define __ISCSI_NET_UTIL_h__
+
+#define ISCSI_HWADDRESS_BUF_SIZE 18
+
+extern int net_get_transport_name_from_netdev(char *netdev, char *transport);
+extern int net_get_netdev_from_hwaddress(char *hwaddress, char *netdev);
+extern int net_setup_netdev(char *netdev, char *local_ip, char *mask,
+			    char *gateway, char *remote_ip, int needs_bringup);
+
+#endif
diff -Naurp open-iscsi-2.0-872-rc4-bnx2i.base/iscsiuio/src/unix/iscsid_ipc.c open-iscsi-2.0-872-rc4-bnx2i.build2/iscsiuio/src/unix/iscsid_ipc.c
--- open-iscsi-2.0-872-rc4-bnx2i.base/iscsiuio/src/unix/iscsid_ipc.c	2011-08-14 22:58:02.000000000 -0500
+++ open-iscsi-2.0-872-rc4-bnx2i.build2/iscsiuio/src/unix/iscsid_ipc.c	2011-08-14 23:37:00.000000000 -0500
@@ -221,18 +221,11 @@ static int parse_iface(void *arg)
 	data = (iscsid_uip_broadcast_t *) arg;
 
 	LOG_INFO(PFX "Received request for '%s' to set IP address: '%s' "
-		 "VLAN: '%s'",
+		 "VLAN: '%d'",
 		 data->u.iface_rec.rec.netdev,
-		 data->u.iface_rec.rec.ipaddress, data->u.iface_rec.rec.vlan);
+		 data->u.iface_rec.rec.ipaddress, data->u.iface_rec.rec.vlan_id);
 
-	vlan = atoi(data->u.iface_rec.rec.vlan);
-	if ((valid_vlan(vlan) == 0) &&
-	    (strcmp(data->u.iface_rec.rec.vlan, "") != 0)) {
-		LOG_ERR(PFX "Invalid VLAN tag: '%s'",
-			data->u.iface_rec.rec.vlan)
-		    rc = -EIO;
-		goto early_exit;
-	}
+	vlan = data->u.iface_rec.rec.vlan_id;
 
 	/*  Detect for CIDR notation and strip off the netmask if present */
 	rc = decode_cidr(data->u.iface_rec.rec.ipaddress, &ipam, &prefix_len);
@@ -590,7 +583,7 @@ int process_iscsid_broadcast(int s2)
 	}
 
 	/*  This will be freed by parse_iface_thread() */
-	data = (iscsid_uip_broadcast_t *) malloc(sizeof(*data));
+	data = (iscsid_uip_broadcast_t *) calloc(1, sizeof(*data));
 	if (data == NULL) {
 		LOG_ERR(PFX "Couldn't allocate memory for iface data");
 		return -ENOMEM;
