Index: open-iscsi-2.0-873/libiscsi/libiscsi.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/libiscsi.c
@@ -0,0 +1,612 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syslog.h>
+#include "libiscsi.h"
+#include "idbm.h"
+#include "discovery.h"
+#include "log.h"
+#include "sysfs.h"
+#include "iscsi_sysfs.h"
+#include "session_info.h"
+#include "iscsi_util.h"
+#include "sysdeps.h"
+#include "iface.h"
+#include "iscsi_proto.h"
+#include "fw_context.h"
+#include "iscsid_req.h"
+#include "iscsi_err.h"
+
+#define CHECK(a) { context->error_str[0] = 0; rc = a; if (rc) goto leave; }
+
+/* UGLY, not thread safe :( */
+static int sysfs_initialized = 0;
+
+struct libiscsi_context {
+	char error_str[256];
+	/* For get_parameter_helper() */
+	const char *parameter;
+	char *value;
+};
+
+static void libiscsi_log(int prio, void *priv, const char *fmt, va_list ap)
+{
+	struct libiscsi_context *context = priv;
+
+	if (prio > LOG_ERR) /* We are only interested in errors (or worse) */
+		return;
+
+	vsnprintf(context->error_str, sizeof(context->error_str), fmt, ap);
+}
+
+struct libiscsi_context *libiscsi_init(void)
+{
+	struct libiscsi_context *context;
+
+	context = calloc(1, sizeof *context);
+	if (!context)
+		return NULL;
+
+	log_init("libiscsi", 1024, libiscsi_log, context);
+	if (!sysfs_initialized) {
+		sysfs_init();
+		sysfs_initialized = 1;
+	}
+	increase_max_files();
+	if (idbm_init(NULL)) {
+		sysfs_cleanup();
+		free(context);
+		return NULL;
+	}
+
+	iface_setup_host_bindings();
+
+	return context;
+}
+
+void libiscsi_cleanup(struct libiscsi_context *context)
+{
+	idbm_terminate();
+	free_transports();
+	sysfs_cleanup();
+	free(context);
+}
+
+static void free_iface_list(struct list_head *ifaces)
+{
+	struct iface_rec *iface, *tmp_iface;
+
+	list_for_each_entry_safe(iface, tmp_iface, ifaces, list) {
+		list_del(&iface->list);
+		free(iface);
+	}
+}
+
+static void free_rec_list(struct list_head *rec_list)
+{
+	struct node_rec *rec, *tmp;
+	
+	list_for_each_entry_safe(rec, tmp, rec_list, list) {
+		list_del(&rec->list);
+		free(rec);
+	}
+}
+
+int libiscsi_discover_sendtargets(struct libiscsi_context *context,
+	const char *address, int port,
+	const struct libiscsi_auth_info *auth_info,
+	int *nr_found, struct libiscsi_node **found_nodes)
+{
+	struct discovery_rec drec;
+	LIST_HEAD(bound_rec_list);
+	struct node_rec *rec;
+	int rc = 0, found = 0;
+
+	INIT_LIST_HEAD(&bound_rec_list);
+
+	if (nr_found)
+		*nr_found = 0;
+	if (found_nodes)
+		*found_nodes = NULL;
+
+	CHECK(libiscsi_verify_auth_info(context, auth_info))
+
+	/* Fill the drec struct with all needed info */
+	memset(&drec, 0, sizeof drec);
+	idbm_sendtargets_defaults(&drec.u.sendtargets);
+	drec.type = DISCOVERY_TYPE_SENDTARGETS;
+	strlcpy(drec.address, address, sizeof(drec.address));
+	drec.port = port ? port : ISCSI_LISTEN_PORT;
+	switch(auth_info ? auth_info->method : libiscsi_auth_none) {
+	case libiscsi_auth_chap:
+		drec.u.sendtargets.auth.authmethod = AUTH_METHOD_CHAP;
+		strlcpy(drec.u.sendtargets.auth.username,
+			auth_info->chap.username, AUTH_STR_MAX_LEN);
+		strlcpy((char *)drec.u.sendtargets.auth.password,
+			auth_info->chap.password, AUTH_STR_MAX_LEN);
+		drec.u.sendtargets.auth.password_length =
+			strlen((char *)drec.u.sendtargets.auth.password);
+		strlcpy(drec.u.sendtargets.auth.username_in,
+			auth_info->chap.reverse_username, AUTH_STR_MAX_LEN);
+		strlcpy((char *)drec.u.sendtargets.auth.password_in,
+			auth_info->chap.reverse_password, AUTH_STR_MAX_LEN);
+		drec.u.sendtargets.auth.password_in_length =
+			strlen((char *)drec.u.sendtargets.auth.password_in);
+		break;
+	}
+
+	CHECK(idbm_add_discovery(&drec))
+
+	CHECK(idbm_bind_ifaces_to_nodes(discovery_sendtargets,
+					&drec, NULL, &bound_rec_list))
+
+	/* now add/update records */
+	list_for_each_entry(rec, &bound_rec_list, list) {
+		CHECK(idbm_add_node(rec, &drec, 1 /* overwrite */))
+		found++;
+	}
+
+	if (nr_found)
+		*nr_found = found;
+
+	if (found_nodes && found) {
+		*found_nodes = calloc(found, sizeof **found_nodes);
+		if (*found_nodes == NULL) {
+			snprintf(context->error_str,
+				 sizeof(context->error_str), strerror(ENOMEM));
+			rc = ENOMEM;
+			goto leave;
+		}
+		found = 0;
+		list_for_each_entry(rec, &bound_rec_list, list) {
+			strlcpy((*found_nodes)[found].name, rec->name,
+				 LIBISCSI_VALUE_MAXLEN);
+			(*found_nodes)[found].tpgt = rec->tpgt;
+			strlcpy((*found_nodes)[found].address,
+				 rec->conn[0].address, NI_MAXHOST);
+			(*found_nodes)[found].port = rec->conn[0].port;
+			strlcpy((*found_nodes)[found].iface,
+				 rec->iface.name, LIBISCSI_VALUE_MAXLEN);
+			found++;
+		}
+	}
+
+leave:
+	free_rec_list(&bound_rec_list);
+	return rc;
+}
+
+int libiscsi_discover_firmware(struct libiscsi_context *context,
+	int *nr_found, struct libiscsi_node **found_nodes)
+{
+	struct list_head targets, ifaces, rec_list;
+	discovery_rec_t drec;
+	int rc = 0;
+
+	INIT_LIST_HEAD(&targets);
+	INIT_LIST_HEAD(&ifaces);
+	INIT_LIST_HEAD(&rec_list);
+
+	if (nr_found) {
+		*nr_found = 0;
+	}
+
+	if (found_nodes) {
+		*found_nodes = NULL;
+	}
+
+	rc = fw_get_targets(&targets);
+	if (rc) {
+		log_error("%s: Could not get list of targets from firmware "
+			  "(err %d).\n", __func__, rc);
+		return rc;
+	}
+
+	CHECK(iface_create_ifaces_from_boot_contexts(&ifaces, &targets));
+
+	memset(&drec, 0, sizeof(drec));
+	drec.type = DISCOVERY_TYPE_FW;
+	rc = idbm_bind_ifaces_to_nodes(discovery_fw, &drec, &ifaces, &rec_list);
+	if (rc) {
+		log_error("%s: Could not determine target nodes from firmware "
+			  "(err %d).\n", __func__, rc);
+		goto leave;
+	}
+
+	int node_count = 0;
+	struct list_head *pos;
+	list_for_each(pos, &rec_list) {
+		++node_count;
+	}
+
+	struct libiscsi_node* new_nodes;
+	/* allocate enough space for all the nodes */
+	new_nodes = calloc(node_count, sizeof *new_nodes);
+	if (new_nodes == NULL) {
+		rc = ENOMEM;
+		log_error("%s: %s.\n", __func__, strerror(ENOMEM));
+		goto leave;
+	}
+
+	struct node_rec *rec;
+	struct libiscsi_node *new_node = new_nodes;
+	/* in one loop, add nodes to idbm and create libiscsi_node entries */
+	list_for_each_entry(rec, &rec_list, list) {
+		CHECK(idbm_add_node(rec, NULL, 1 /* overwrite */));
+
+		strlcpy(new_node->name, rec->name, LIBISCSI_VALUE_MAXLEN);
+		new_node->tpgt = rec->tpgt;
+		strlcpy(new_node->address, rec->conn[0].address, NI_MAXHOST);
+		new_node->port = rec->conn[0].port;
+		strlcpy(new_node->iface, rec->iface.name, LIBISCSI_VALUE_MAXLEN);
+
+		++new_node;
+	}
+
+	/* update output parameters */
+	if (nr_found) {
+		*nr_found = node_count;
+	}
+	if (found_nodes) {
+		*found_nodes = new_nodes;
+	}
+
+leave:
+	fw_free_targets(&targets);
+
+	free_iface_list(&ifaces);
+	free_rec_list(&rec_list);
+
+	return rc;
+}
+
+int libiscsi_verify_auth_info(struct libiscsi_context *context,
+	const struct libiscsi_auth_info *auth_info)
+{
+	switch(auth_info ? auth_info->method : libiscsi_auth_none) {
+	case libiscsi_auth_none:
+		break;
+	case libiscsi_auth_chap:
+		if (!auth_info->chap.username[0]) {
+			strcpy(context->error_str, "Empty username");
+			return EINVAL;
+		}
+		if (!auth_info->chap.password[0]) {
+			strcpy(context->error_str, "Empty password");
+			return EINVAL;
+		}
+		if (auth_info->chap.reverse_username[0] &&
+		    !auth_info->chap.reverse_password[0]) {
+			strcpy(context->error_str, "Empty reverse password");
+		    	return EINVAL;
+		}
+		break;
+	default:
+		sprintf(context->error_str,
+			"Invalid authentication method: %d",
+			(int)auth_info->method);
+		return EINVAL;
+	}
+	return 0;
+}
+
+int libiscsi_node_set_auth(struct libiscsi_context *context,
+    const struct libiscsi_node *node,
+    const struct libiscsi_auth_info *auth_info)
+{
+	int rc = 0;
+
+	CHECK(libiscsi_verify_auth_info(context, auth_info))
+
+	switch(auth_info ? auth_info->method : libiscsi_auth_none) {
+	case libiscsi_auth_none:
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.authmethod", "None"))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.username", ""))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.password", ""))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.username_in", ""))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.password_in", ""))
+		break;
+
+	case libiscsi_auth_chap:
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.authmethod", "CHAP"))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.username",
+			auth_info->chap.username))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.password",
+			auth_info->chap.password))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.username_in",
+			auth_info->chap.reverse_username))
+		CHECK(libiscsi_node_set_parameter(context, node,
+			"node.session.auth.password_in",
+			auth_info->chap.reverse_password))
+		break;
+	}
+leave:
+	return rc;
+}
+
+int libiscsi_node_get_auth(struct libiscsi_context *context,
+    const struct libiscsi_node *node,
+    struct libiscsi_auth_info *auth_info)
+{
+	int rc = 0;
+	char value[LIBISCSI_VALUE_MAXLEN];
+
+	memset(auth_info, 0, sizeof *auth_info);
+
+	CHECK(libiscsi_node_get_parameter(context, node,
+			"node.session.auth.authmethod", value))
+
+	if (!strcmp(value, "None")) {
+		auth_info->method = libiscsi_auth_none;
+	} else if (!strcmp(value, "CHAP")) {
+		auth_info->method = libiscsi_auth_chap;
+		CHECK(libiscsi_node_get_parameter(context, node,
+			"node.session.auth.username",
+			auth_info->chap.username))
+		CHECK(libiscsi_node_get_parameter(context, node,
+			"node.session.auth.password",
+			auth_info->chap.password))
+		CHECK(libiscsi_node_get_parameter(context, node,
+			"node.session.auth.username_in",
+			auth_info->chap.reverse_username))
+		CHECK(libiscsi_node_get_parameter(context, node,
+			"node.session.auth.password_in",
+			auth_info->chap.reverse_password))
+	} else {
+		snprintf(context->error_str, sizeof(context->error_str),
+			 "unknown authentication method: %s", value);
+		rc = EINVAL;
+	}
+leave:
+	return rc;
+}
+
+static void node_to_rec(const struct libiscsi_node *node,
+	struct node_rec *rec)
+{
+	memset(rec, 0, sizeof *rec);
+	idbm_node_setup_defaults(rec);
+	strlcpy(rec->name, node->name, TARGET_NAME_MAXLEN);
+	rec->tpgt = node->tpgt;
+	strlcpy(rec->conn[0].address, node->address, NI_MAXHOST);
+	rec->conn[0].port = node->port;
+}
+
+int login_helper(void *data, node_rec_t *rec)
+{
+	char *iface = (char*)data;
+	if (strcmp(iface, rec->iface.name))
+		/* different iface, skip it */
+		return -1;
+
+	int rc = iscsid_req_by_rec(MGMT_IPC_SESSION_LOGIN, rec);
+	if (rc) {
+		iscsi_err_print_msg(rc);
+		rc = ENOTCONN;
+	}
+	return rc;
+}
+
+int libiscsi_node_login(struct libiscsi_context *context,
+	const struct libiscsi_node *node)
+{
+	int nr_found = 0, rc;
+
+	CHECK(idbm_for_each_iface(&nr_found, (void*)node->iface, login_helper,
+		(char *)node->name, node->tpgt,
+		(char *)node->address, node->port))
+	if (nr_found == 0) {
+		strcpy(context->error_str, "No such node");
+		rc = ENODEV;
+	}
+leave:
+	return rc;
+}
+
+static int logout_helper(void *data, struct session_info *info)
+{
+	int rc;
+	struct node_rec *rec = data;
+
+	if (!iscsi_match_session(rec, info))
+		/* Tell iscsi_sysfs_for_each_session this session was not a
+		   match so that it will not increase nr_found. */
+		return -1;
+
+	rc = iscsid_req_by_sid(MGMT_IPC_SESSION_LOGOUT, info->sid);
+	if (rc) {
+		iscsi_err_print_msg(rc);
+		rc = EIO;
+	}
+
+	return rc;
+}
+
+int libiscsi_node_logout(struct libiscsi_context *context,
+	const struct libiscsi_node *node)
+{
+	int nr_found = 0, rc;
+	struct node_rec rec;
+
+	node_to_rec(node, &rec);
+	CHECK(iscsi_sysfs_for_each_session(&rec, &nr_found, logout_helper))
+	if (nr_found == 0) {
+		strcpy(context->error_str, "No matching session");
+		rc = ENODEV;
+	}
+leave:
+	return rc;
+}
+
+int libiscsi_node_set_parameter(struct libiscsi_context *context,
+	const struct libiscsi_node *node,
+	const char *parameter, const char *value)
+{
+	int nr_found = 0, rc;
+	struct user_param set_param = {
+		.name = (char *)parameter,
+		.value = (char *)value,
+	};
+
+	CHECK(idbm_for_each_iface(&nr_found, &set_param, idbm_node_set_param,
+		(char *)node->name, node->tpgt,
+		(char *)node->address, node->port))
+	if (nr_found == 0) {
+		strcpy(context->error_str, "No such node");
+		rc = ENODEV;
+	}
+leave:
+	return rc;
+}
+
+static int get_parameter_helper(void *data, node_rec_t *rec)
+{
+	struct libiscsi_context *context = data;
+	recinfo_t *info;
+	int i;
+
+	info = idbm_recinfo_alloc(MAX_KEYS);
+	if (!info) {
+		snprintf(context->error_str, sizeof(context->error_str),
+			 strerror(ENOMEM));
+		return ENOMEM;
+	}
+
+	idbm_recinfo_node(rec, info);
+
+	for (i = 0; i < MAX_KEYS; i++) {
+		if (!info[i].visible)
+			continue;
+
+		if (strcmp(context->parameter, info[i].name))
+			continue;
+
+		strlcpy(context->value, info[i].value, LIBISCSI_VALUE_MAXLEN);
+		break;
+	}
+
+	free(info);
+
+	if (i == MAX_KEYS) {
+		strcpy(context->error_str, "No such parameter");
+		return EINVAL;
+	}
+
+	return 0;
+}
+
+int libiscsi_node_get_parameter(struct libiscsi_context *context,
+	const struct libiscsi_node *node, const char *parameter, char *value)
+{
+	int nr_found = 0, rc = 0;
+
+	context->parameter = parameter;
+	context->value = value;
+
+	/* Note we assume there is only one interface, if not we will get
+	   the value from the last interface iterated over!
+	   This (multiple interfaces) can only happen if someone explicitly
+	   created ones using iscsiadm. Even then this should not be a problem
+	   as most settings should be the same independent of the iface. */
+	CHECK(idbm_for_each_iface(&nr_found, context, get_parameter_helper,
+		(char *)node->name, node->tpgt,
+		(char *)node->address, node->port))
+	if (nr_found == 0) {
+		strcpy(context->error_str, "No such node");
+		rc = ENODEV;
+	}
+leave:
+	return rc;
+}
+
+const char *libiscsi_get_error_string(struct libiscsi_context *context)
+{
+	/* Sometimes the core open-iscsi code does not give us an error
+	   message */
+	if (!context->error_str[0])
+		return "Unknown error";
+
+	return context->error_str;
+}
+
+
+/************************** Utility functions *******************************/
+
+int libiscsi_get_firmware_network_config(
+    struct libiscsi_network_config *config)
+{
+	struct boot_context fw_entry;
+
+	if (!sysfs_initialized) {
+		sysfs_init();
+		sysfs_initialized = 1;
+	}
+
+	memset(config, 0, sizeof *config);
+	memset(&fw_entry, 0, sizeof fw_entry);
+	if (fw_get_entry(&fw_entry))
+		return ENODEV;
+
+	config->dhcp = strlen(fw_entry.dhcp) ? 1 : 0;
+	strncpy(config->iface_name, fw_entry.iface, sizeof fw_entry.iface);
+	strncpy(config->mac_address, fw_entry.mac, sizeof fw_entry.mac);
+	strncpy(config->ip_address, fw_entry.ipaddr, sizeof fw_entry.ipaddr);
+	strncpy(config->netmask, fw_entry.mask, sizeof fw_entry.mask);
+	strncpy(config->gateway, fw_entry.gateway, sizeof fw_entry.gateway);
+	strncpy(config->primary_dns, fw_entry.primary_dns,
+		sizeof fw_entry.primary_dns);
+	strncpy(config->secondary_dns, fw_entry.secondary_dns,
+		sizeof fw_entry.secondary_dns);
+	return 0;
+}
+
+int libiscsi_get_firmware_initiator_name(char *initiatorname)
+{
+	struct boot_context fw_entry;
+
+	if (!sysfs_initialized) {
+		sysfs_init();
+		sysfs_initialized = 1;
+	}
+
+	memset(initiatorname, 0, LIBISCSI_VALUE_MAXLEN);
+	memset(&fw_entry, 0, sizeof fw_entry);
+	if (fw_get_entry(&fw_entry))
+		return ENODEV;
+
+	strncpy(initiatorname, fw_entry.initiatorname,
+		sizeof fw_entry.initiatorname);
+
+	return 0;
+}
Index: open-iscsi-2.0-873/libiscsi/libiscsi.h
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/libiscsi.h
@@ -0,0 +1,344 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#ifndef __LIBISCSI_H
+#define __LIBISCSI_H
+
+#include <netdb.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#if __GNUC__ >= 4
+#define PUBLIC __attribute__ ((visibility("default")))
+#else
+#define PUBLIC
+#endif
+
+/** \brief Maximum length for iSCSI values.
+ *
+ * Maximum length for iSCSI values such as hostnames and parameter values.
+ */
+#define LIBISCSI_VALUE_MAXLEN 256
+
+/** \brief supported authentication methods
+ *
+ * This enum lists all supported authentication methods.
+ */
+enum libiscsi_auth_t {
+    libiscsi_auth_none   /** No authentication */,
+    libiscsi_auth_chap   /** CHAP authentication */,
+};
+
+/** \brief libiscsi context struct
+ *
+ * Note: even though libiscsi uses a context struct, the underlying open-iscsi
+ * code does not, so libiscsi is not thread safe, not even when using one
+ * context per thread!
+ */
+struct libiscsi_context;
+
+/** \brief iSCSI node record
+ *
+ * Struct holding data uniquely identifying an iSCSI node.
+ */
+struct libiscsi_node {
+    char name[LIBISCSI_VALUE_MAXLEN]     /** iSCSI iqn for the node. */;
+    int tpgt                             /** Portal group number. */;
+    /* Note open-iscsi has some code in place for multiple connections in one
+       node record and thus multiple address / port combi's, but this does not
+       get used anywhere, so we keep things simple and assume one connection */
+    char address[NI_MAXHOST]             /** Portal hostname or IP-address. */;
+    int port                             /** Portal port number. */;
+    char iface[LIBISCSI_VALUE_MAXLEN]    /** Interface to connect through. */;
+};
+
+/** \brief libiscsi CHAP authentication information struct
+ *
+ * Struct holding all data needed for CHAP login / authentication. Note that
+ * \e reverse_username may be a 0 length string in which case only forward
+ * authentication will be done.
+ */
+struct libiscsi_chap_auth_info {
+    char username[LIBISCSI_VALUE_MAXLEN]         /** Username */;
+    char password[LIBISCSI_VALUE_MAXLEN]         /** Password */;
+    char reverse_username[LIBISCSI_VALUE_MAXLEN] /** Reverse Username */;
+    char reverse_password[LIBISCSI_VALUE_MAXLEN] /** Reverse Password */;
+};
+
+/** \brief generic libiscsi authentication information struct
+ *
+ * Struct holding authentication information for discovery and login.
+ */
+struct libiscsi_auth_info {
+    enum libiscsi_auth_t method /** Authentication method to use */;
+    union {
+        struct libiscsi_chap_auth_info chap /** Chap specific info */;
+    } /** Union holding method depenend info */;
+};
+
+/** \brief Initalize libiscsi
+ *
+ * This function creates a libiscsi context and initalizes it. This context
+ * is need to use other libiscsi funtions.
+ *
+ * \return     A pointer to the created context, or NULL in case of an error.
+ */
+PUBLIC struct libiscsi_context *libiscsi_init(void);
+
+/** \brief Cleanup libiscsi used resource
+ *
+ * This function cleanups any used resources and then destroys the passed
+ * context. After this the passed in context may no longer be used!
+ *
+ * \param context                libiscsi context to operate on.
+ */
+PUBLIC void libiscsi_cleanup(struct libiscsi_context *context);
+
+/** \brief Discover iSCSI nodes using sendtargets and add them to the node db.
+ *
+ * This function connects to the given address and port and then tries to
+ * discover iSCSI nodes using the sendtargets protocol. Any found nodes are
+ * added to the local iSCSI node database and are returned in a dynamically
+ * allocated array.
+ *
+ * Note that the (optional) authentication info is for authenticating the
+ * discovery, and is not for the found nodes! If the connection(s) to the
+ * node(s) need authentication too, you can set the username / password for
+ * those (which can be different!) using the libiscsi_node_set_auth() function.
+ *
+ * \param context                libiscsi context to operate on.
+ * \param address                Hostname or IP-address to connect to.
+ * \param port                   Port to connect to, or 0 for the default port.
+ * \param auth_info              Authentication information, or NULL.
+ * \param nr_found		 The number of found nodes will be returned
+ *                               through this pointer if not NULL.
+ * \param found_nodes            The address of the dynamically allocated array
+ *                               of found nodes will be returned through this
+ *                               pointer if not NULL. The caller must free this
+ *                               array using free().
+ * \return                       0 on success, otherwise a standard error code
+ *                               (from errno.h).
+ */
+PUBLIC int libiscsi_discover_sendtargets(struct libiscsi_context *context,
+    const char *address, int port, const struct libiscsi_auth_info *auth_info,
+    int *nr_found, struct libiscsi_node **found_nodes);
+
+/** \brief Read iSCSI node info from firmware and add them to the node db.
+ *
+ * This function discovers iSCSI nodes using firmware (ppc or ibft). Any found
+ * nodes are added to the local iSCSI node database and are returned in a
+ * dynamically allocated array.
+ *
+ * Note that unlike sendtargets discovery, this function will also read
+ * authentication info and store that in the database too.
+ *
+ * Note this function currently is a stub which will always return -EINVAL
+ * (IOW it is not yet implemented)
+ *
+ * \param context                libiscsi context to operate on.
+ * \param nr_found		 The number of found nodes will be returned
+ *                               through this pointer if not NULL.
+ * \param found_nodes            The address of the dynamically allocated array
+ *                               of found nodes will be returned through this
+ *                               pointer if not NULL. The caller must free this
+ *                               array using free().
+ * \return                       0 on success, otherwise a standard error code
+ *                               (from errno.h).
+ */
+PUBLIC int libiscsi_discover_firmware(struct libiscsi_context *context,
+    int *nr_found, struct libiscsi_node **found_nodes);
+
+/** \brief Check validity of the given authentication info.
+ *
+ * This function checks the validity of the given authentication info. For 
+ * example in case of CHAP, if the username and password are not empty.
+ *
+ * This function is mainly intended for use by language bindings.
+ *
+ * \param context                libiscsi context to operate on.
+ * \param auth_info              Authentication information to check.
+ * \return                       0 on success, otherwise EINVAL.
+ */
+PUBLIC int libiscsi_verify_auth_info(struct libiscsi_context *context,
+	const struct libiscsi_auth_info *auth_info);
+
+/** \brief Set the authentication info for the given node.
+ *
+ * This function sets the authentication information for the node described by
+ * the given node record. This will overwrite any existing authentication
+ * information.
+ *
+ * This is the way to specify authentication information for nodes found
+ * through sendtargets discovery.
+ *
+ * Note:
+ * 1) This is a convience wrapper around libiscsi_node_set_parameter(),
+ *    setting the node.session.auth.* parameters.
+ * 2) For nodes found through firmware discovery the authentication information
+ *    has already been set from the firmware.
+ * 3) \e auth_info may be NULL in which case any existing authinfo will be
+ *    cleared.
+ *
+ * \param context                libiscsi context to operate on.
+ * \param node                   iSCSI node to set auth information of
+ * \param auth_info              Authentication information, or NULL.
+ * \return                       0 on success, otherwise a standard error code
+ *                               (from errno.h).
+ */
+PUBLIC int libiscsi_node_set_auth(struct libiscsi_context *context,
+    const struct libiscsi_node *node,
+    const struct libiscsi_auth_info *auth_info);
+
+/** \brief Get the authentication info for the given node.
+ *
+ * This function gets the authentication information for the node described by
+ * the given node record.
+ *
+ * \param context                libiscsi context to operate on.
+ * \param node                   iSCSI node to set auth information of
+ * \param auth_info              Pointer to a libiscsi_auth_info struct where
+ *                               the retreived information will be stored.
+ * \return                       0 on success, otherwise a standard error code
+ *                               (from errno.h).
+ */
+PUBLIC int libiscsi_node_get_auth(struct libiscsi_context *context,
+    const struct libiscsi_node *node,
+    struct libiscsi_auth_info *auth_info);
+
+/** \brief Login to an iSCSI node.
+ *
+ * Login to the iSCSI node described by the given node record.
+ *
+ * \param context       libiscsi context to operate on.
+ * \param node          iSCSI node to login to.
+ * \return              0 on success, otherwise a standard error code
+ *                      (from errno.h).
+ */
+PUBLIC int libiscsi_node_login(struct libiscsi_context *context,
+    const struct libiscsi_node *node);
+
+/** \brief Logout of an iSCSI node.
+ *
+ * Logout of the iSCSI node described by the given node record.
+ *
+ * \param context       libiscsi context to operate on.
+ * \param node          iSCSI node to logout from.
+ * \return              0 on success, otherwise a standard error code
+ *                      (from errno.h).
+ */
+PUBLIC int libiscsi_node_logout(struct libiscsi_context *context,
+    const struct libiscsi_node *node);
+
+/** \brief Set an iSCSI parameter for the given node
+ *
+ * Set the given nodes iSCSI parameter named by \e parameter to value \e value.
+ *
+ * \param context       libiscsi context to operate on.
+ * \param node          iSCSI node to change a parameter from.
+ * \param parameter     Name of the parameter to set.
+ * \param value         Value to set the parameter too.
+ * \return              0 on success, otherwise a standard error code
+ *                      (from errno.h).
+ */
+PUBLIC int libiscsi_node_set_parameter(struct libiscsi_context *context,
+    const struct libiscsi_node *node,
+    const char *parameter, const char *value);
+
+/** \brief Get the value of an iSCSI parameter for the given node
+ *
+ * Get the value of the given nodes iSCSI parameter named by \e parameter.
+ *
+ * \param context       libiscsi context to operate on.
+ * \param node          iSCSI node to change a parameter from.
+ * \param parameter     Name of the parameter to get.
+ * \param value         The retreived value is stored here, this buffer must be
+ *                      atleast LIBISCSI_VALUE_MAXLEN bytes large.
+ * \return              0 on success, otherwise a standard error code
+ *                      (from errno.h).
+ */
+PUBLIC int libiscsi_node_get_parameter(struct libiscsi_context *context,
+    const struct libiscsi_node *node, const char *parameter, char *value);
+
+/** \brief Get human readable string describing the last libiscsi error.
+ *
+ * This function can be called to get a human readable error string when a
+ * libiscsi function has returned an error. This function uses a single buffer
+ * per context, thus the result is only valid as long as no other libiscsi
+ * calls are made on the same context after the failing function call.
+ *
+ * \param context       libiscsi context to operate on.
+ *
+ * \return human readable string describing the last libiscsi error.
+ */
+PUBLIC const char *libiscsi_get_error_string(struct libiscsi_context *context);
+
+
+/************************** Utility functions *******************************/
+
+/** \brief libiscsi network config struct
+ *
+ * libiscsi network config struct.
+ */
+struct libiscsi_network_config {
+    int dhcp                                  /** Using DHCP? (boolean). */;
+    char iface_name[LIBISCSI_VALUE_MAXLEN]    /** Interface name. */;
+    char mac_address[LIBISCSI_VALUE_MAXLEN]   /** MAC address. */;
+    char ip_address[LIBISCSI_VALUE_MAXLEN]    /** IP address. */;
+    char netmask[LIBISCSI_VALUE_MAXLEN]       /** Netmask. */;
+    char gateway[LIBISCSI_VALUE_MAXLEN]       /** IP of Default gateway. */;
+    char primary_dns[LIBISCSI_VALUE_MAXLEN]   /** IP of the Primary DNS. */;
+    char secondary_dns[LIBISCSI_VALUE_MAXLEN] /** IP of the Secondary DNS. */;
+};
+
+/** \brief Get network configuration information from iscsi firmware
+ *
+ * Function can be called to get the network configuration information
+ * (like dhcp, ip, netmask, default gateway, etc.) from the firmware of a
+ * network adapter with iscsi boot firmware.
+ *
+ * Note that not all fields of the returned struct are necessarilly filled,
+ * unset fields contain a 0 length string.
+ *
+ * \param config        pointer to a libiscsi_network_config struct to fill.
+ *
+ * \return              0 on success, ENODEV when no iscsi firmware was found.
+ */
+PUBLIC int libiscsi_get_firmware_network_config(
+    struct libiscsi_network_config *config);
+
+/** \brief Get the initiator name (iqn) from the iscsi firmware
+ *
+ * Get the initiator name (iqn) from the iscsi firmware.
+ *
+ * \param initiatorname The initiator name is stored here, this buffer must be
+ *                      atleast LIBISCSI_VALUE_MAXLEN bytes large.
+ * \return              0 on success, ENODEV when no iscsi firmware was found.
+ */
+PUBLIC int libiscsi_get_firmware_initiator_name(char *initiatorname);
+
+#undef PUBLIC
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif
Index: open-iscsi-2.0-873/libiscsi/Makefile
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/Makefile
@@ -0,0 +1,58 @@
+# This Makefile will work only with GNU make.
+
+OSNAME=$(shell uname -s)
+OPTFLAGS ?= -O2 -g
+WARNFLAGS ?= -Wall -Wstrict-prototypes
+CFLAGS = $(OPTFLAGS) $(WARNFLAGS) -I../include -I../usr \
+		-D$(OSNAME) -fPIC -D_GNU_SOURCE -fvisibility=hidden
+LIB = libiscsi.so.0
+TESTS = tests/test_discovery_sendtargets tests/test_discovery_firmware
+TESTS += tests/test_login tests/test_logout tests/test_params
+TESTS += tests/test_get_network_config tests/test_get_initiator_name
+TESTS += tests/test_set_auth tests/test_get_auth
+
+COMMON_SRCS = sysdeps.o
+# sources shared between iscsid, iscsiadm and iscsistart
+ISCSI_LIB_SRCS = netlink.o transport.o iser.o cxgbi.o be2iscsi.o iscsi_timer.o initiator_common.o iscsi_err.o session_info.o iscsi_util.o io.o auth.o discovery.o login.o log.o md5.o sha1.o iface.o idbm.o sysfs.o iscsi_sysfs.o iscsi_net_util.o iscsid_req.o
+FW_PARAM_SRCS = fw_entry.o prom_lex.o prom_parse.tab.o fwparam_ppc.o fwparam_sysfs.o
+
+# sources shared with the userspace utils, note we build these separately
+# to get PIC versions.
+COMMON_OBJS = $(patsubst %.o, common-objs/%.o, $(COMMON_SRCS))
+USR_OBJS = $(patsubst %.o, usr-objs/%.o, $(ISCSI_LIB_SRCS) strings.o)
+FW_OBJS = $(patsubst %.o, fw-objs/%.o, $(FW_PARAM_SRCS))
+
+# Flags for the tests
+tests/% : CFLAGS = $(OPTFLAGS) $(WARNFLAGS) -I.
+
+all: lib tests
+
+lib: $(LIB)
+tests: $(TESTS)
+
+common-objs/%.o: ../utils/sysdeps/%.c
+	mkdir -p common-objs
+	$(CC) $(CFLAGS) -c $< -o $@
+
+usr-objs/%.o: ../usr/%.c
+	mkdir -p usr-objs
+	$(CC) $(CFLAGS) -c $< -o $@
+
+fw-objs/%.o: ../utils/fwparam_ibft/%.c
+	mkdir -p fw-objs
+	$(CC) $(CFLAGS) -c $< -o $@
+
+$(LIB): $(COMMON_OBJS) $(FW_OBJS) $(USR_OBJS) libiscsi.o
+	$(CC) $(CFLAGS) -shared -Wl,-soname,$(LIB) $^ -o $@
+	ln -s -f $(LIB) libiscsi.so
+
+$(TESTS): $(FW_OBJS) $(COMMON_OBJS) $(USR_OBJS) $(LIB)
+
+clean:
+	rm -rf *.o common-objs usr-objs fw-objs libuip-objs libiscsi.so* \
+			.depend *~ $(TESTS) tests/*~
+
+depend:
+	gcc $(CFLAGS) -M `ls *.c` > .depend
+
+-include .depend ../usr/.depend
Index: open-iscsi-2.0-873/libiscsi/pylibiscsi.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/pylibiscsi.c
@@ -0,0 +1,638 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <Python.h>
+#include "libiscsi.h"
+
+static struct libiscsi_context *context = NULL;
+
+/****************************** helpers ***********************************/
+static int check_string(const char *string)
+{
+	if (strlen(string) >= LIBISCSI_VALUE_MAXLEN) {
+		PyErr_SetString(PyExc_ValueError, "string too long");
+		return -1;
+	}
+	return 0;
+}
+
+/********************** PyIscsiChapAuthInfo ***************************/
+
+typedef struct {
+	PyObject_HEAD
+
+	struct libiscsi_auth_info info;
+} PyIscsiChapAuthInfo;
+
+static int PyIscsiChapAuthInfo_init(PyObject *self, PyObject *args,
+				    PyObject *kwds)
+{
+	int i;
+	PyIscsiChapAuthInfo *chap = (PyIscsiChapAuthInfo *)self;
+	char *kwlist[] = {"username", "password", "reverse_username",
+				"reverse_password", NULL};
+	const char *string[4] = { NULL, NULL, NULL, NULL };
+
+	if (!PyArg_ParseTupleAndKeywords(args, kwds,
+					"zz|zz:chapAuthInfo.__init__",
+					kwlist, &string[0], &string[1],
+					&string[2], &string[3]))
+		return -1;
+
+	for (i = 0; i < 4; i++)
+		if (string[i] && check_string(string[i]))
+			return -1;
+
+	memset (&chap->info, 0, sizeof(chap->info));
+	chap->info.method = libiscsi_auth_chap;
+	if (string[0])
+		strcpy(chap->info.chap.username, string[0]);
+	if (string[1])
+		strcpy(chap->info.chap.password, string[1]);
+	if (string[2])
+		strcpy(chap->info.chap.reverse_username, string[2]);
+	if (string[3])
+		strcpy(chap->info.chap.reverse_password, string[3]);
+
+	if (libiscsi_verify_auth_info(context, &chap->info)) {
+		PyErr_SetString(PyExc_ValueError,
+				libiscsi_get_error_string(context));
+		return -1;
+	}
+	return 0;
+}
+
+static PyObject *PyIscsiChapAuthInfo_get(PyObject *self, void *data)
+{
+	PyIscsiChapAuthInfo *chap = (PyIscsiChapAuthInfo *)self;
+	const char *attr = (const char *)data;
+
+	if (!strcmp(attr, "username")) {
+		return PyString_FromString(chap->info.chap.username);
+	} else if (!strcmp(attr, "password")) {
+		return PyString_FromString(chap->info.chap.password);
+	} else if (!strcmp(attr, "reverse_username")) {
+		return PyString_FromString(chap->info.chap.reverse_username);
+	} else if (!strcmp(attr, "reverse_password")) {
+		return PyString_FromString(chap->info.chap.reverse_password);
+	}
+	return NULL;
+}
+
+static int PyIscsiChapAuthInfo_set(PyObject *self, PyObject *value, void *data)
+{
+	PyIscsiChapAuthInfo *chap = (PyIscsiChapAuthInfo *)self;
+	const char *attr = (const char *)data;
+	const char *str;
+
+	if (!PyArg_Parse(value, "s", &str) || check_string(str))
+		return -1;
+
+	if (!strcmp(attr, "username")) {
+		strcpy(chap->info.chap.username, str);
+	} else if (!strcmp(attr, "password")) {
+		strcpy(chap->info.chap.password, str);
+	} else if (!strcmp(attr, "reverse_username")) {
+		strcpy(chap->info.chap.reverse_username, str);
+	} else if (!strcmp(attr, "reverse_password")) {
+		strcpy(chap->info.chap.reverse_password, str);
+	}
+
+	return 0;
+}
+
+static int PyIscsiChapAuthInfo_compare(PyIscsiChapAuthInfo *self,
+				       PyIscsiChapAuthInfo *other)
+{
+	int r;
+
+	r = strcmp(self->info.chap.username, other->info.chap.username);
+	if (r)
+		return r;
+
+	r = strcmp(self->info.chap.password, other->info.chap.password);
+	if (r)
+		return r;
+
+	r = strcmp(self->info.chap.reverse_username,
+		   other->info.chap.reverse_username);
+	if (r)
+		return r;
+
+	r = strcmp(self->info.chap.reverse_password,
+		   other->info.chap.reverse_password);
+	return r;
+}
+
+static PyObject *PyIscsiChapAuthInfo_str(PyObject *self)
+{
+	PyIscsiChapAuthInfo *chap = (PyIscsiChapAuthInfo *)self;
+	char s[1024], reverse[512] = "";
+
+	if (chap->info.chap.reverse_username[0])
+		snprintf(reverse, sizeof(reverse), ", %s:%s",
+			 chap->info.chap.reverse_username,
+			 chap->info.chap.reverse_password);
+
+	snprintf(s, sizeof(s), "%s:%s%s", chap->info.chap.username,
+		 chap->info.chap.password, reverse);
+
+	return PyString_FromString(s);
+}
+
+static struct PyGetSetDef PyIscsiChapAuthInfo_getseters[] = {
+	{"username", (getter)PyIscsiChapAuthInfo_get,
+		(setter)PyIscsiChapAuthInfo_set,
+		"username", "username"},
+	{"password", (getter)PyIscsiChapAuthInfo_get,
+		(setter)PyIscsiChapAuthInfo_set,
+		"password", "password"},
+	{"reverse_username", (getter)PyIscsiChapAuthInfo_get,
+		(setter)PyIscsiChapAuthInfo_set,
+		"reverse_username", "reverse_username"},
+	{"reverse_password", (getter)PyIscsiChapAuthInfo_get,
+		(setter)PyIscsiChapAuthInfo_set,
+		"reverse_password", "reverse_password"},
+	{NULL}
+};
+
+PyTypeObject PyIscsiChapAuthInfo_Type = {
+	PyObject_HEAD_INIT(NULL)
+	.tp_name = "libiscsi.chapAuthInfo",
+	.tp_basicsize = sizeof (PyIscsiChapAuthInfo),
+	.tp_getset = PyIscsiChapAuthInfo_getseters,
+	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |
+		    Py_TPFLAGS_BASETYPE,
+	.tp_compare = (cmpfunc)PyIscsiChapAuthInfo_compare,
+	.tp_init = PyIscsiChapAuthInfo_init,
+	.tp_str = PyIscsiChapAuthInfo_str,
+	.tp_new = PyType_GenericNew,
+	.tp_doc = "iscsi chap authentication information.",
+};
+
+/***************************** PyIscsiNode  ********************************/
+
+typedef struct {
+	PyObject_HEAD
+
+	struct libiscsi_node node;
+} PyIscsiNode;
+
+static int PyIscsiNode_init(PyObject *self, PyObject *args, PyObject *kwds)
+{
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	char *kwlist[] = {"name", "tpgt", "address", "port", "iface", NULL};
+	const char *name = NULL, *address = NULL, *iface = NULL;
+	int tpgt = -1, port = 3260;
+
+	if (!PyArg_ParseTupleAndKeywords(args, kwds, "s|isis:node.__init__",
+					 kwlist, &name, &tpgt, &address,
+					 &port, &iface))
+		return -1;
+	if (address == NULL) {
+		PyErr_SetString(PyExc_ValueError, "address not set");
+		return -1;
+	}
+	if (check_string(name) || check_string(address) || check_string(iface))
+		return -1;
+
+	strcpy(node->node.name, name);
+	node->node.tpgt = tpgt;
+	strcpy(node->node.address, address);
+	node->node.port = port;
+	strcpy(node->node.iface, iface);
+
+	return 0;
+}
+
+static PyObject *PyIscsiNode_get(PyObject *self, void *data)
+{
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	const char *attr = (const char *)data;
+
+	if (!strcmp(attr, "name")) {
+		return PyString_FromString(node->node.name);
+	} else if (!strcmp(attr, "tpgt")) {
+		return PyInt_FromLong(node->node.tpgt);
+	} else if (!strcmp(attr, "address")) {
+		return PyString_FromString(node->node.address);
+	} else if (!strcmp(attr, "port")) {
+		return PyInt_FromLong(node->node.port);
+	} else if (!strcmp(attr, "iface")) {
+		return PyString_FromString(node->node.iface);
+	}
+	return NULL;
+}
+
+static int PyIscsiNode_set(PyObject *self, PyObject *value, void *data)
+{
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	const char *attr = (const char *)data;
+	const char *str;
+	int i;
+
+	if (!strcmp(attr, "name")) {
+		if (!PyArg_Parse(value, "s", &str) || check_string(str))
+			return -1;
+		strcpy(node->node.name, str);
+	} else if (!strcmp(attr, "tpgt")) {
+		if (!PyArg_Parse(value, "i", &i))
+			return -1;
+		node->node.tpgt = i;
+	} else if (!strcmp(attr, "address")) {
+		if (!PyArg_Parse(value, "s", &str) || check_string(str))
+			return -1;
+		strcpy(node->node.address, str);
+	} else if (!strcmp(attr, "port")) {
+		if (!PyArg_Parse(value, "i", &i))
+			return -1;
+		node->node.port = i;
+	} else if (!strcmp(attr, "iface")) {
+		if (!PyArg_Parse(value, "s", &str) || check_string(str))
+			return -1;
+		strcpy(node->node.iface, str);
+	}
+
+	return 0;
+}
+
+static int PyIscsiNode_compare(PyIscsiNode *self, PyIscsiNode *other)
+{
+	int res;
+
+	res = strcmp(self->node.name, other->node.name);
+	if (res)
+		return res;
+
+	if (self->node.tpgt < other->node.tpgt)
+		return -1;
+	if (self->node.tpgt > other->node.tpgt)
+		return -1;
+
+	res = strcmp(self->node.address, other->node.address);
+	if (res)
+		return res;
+
+	if (self->node.port < other->node.port)
+		return -1;
+	if (self->node.port > other->node.port)
+		return -1;
+
+	res = strcmp(self->node.iface, other->node.iface);
+	if (res)
+		return res;
+
+	return 0;
+}
+
+static PyObject *PyIscsiNode_str(PyObject *self)
+{
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	char s[1024], tpgt[16] = "";
+
+	if (node->node.tpgt != -1)
+		sprintf(tpgt, ",%d", node->node.tpgt);
+
+	snprintf(s, sizeof(s), "%s:%d%s %s", node->node.address,
+		 node->node.port, tpgt, node->node.name);
+
+	return PyString_FromString(s);
+}
+
+static PyObject *PyIscsiNode_login(PyObject *self)
+{
+	PyIscsiNode *node = (PyIscsiNode *)self;
+
+	if (libiscsi_node_login(context, &node->node)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+	Py_RETURN_NONE;
+}
+
+static PyObject *PyIscsiNode_logout(PyObject *self)
+{
+	PyIscsiNode *node = (PyIscsiNode *)self;
+
+	if (libiscsi_node_logout(context, &node->node)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+	Py_RETURN_NONE;
+}
+
+static PyObject *PyIscsiNode_setAuth(PyObject *self, PyObject *args,
+				     PyObject *kwds)
+{
+	char *kwlist[] = {"authinfo", NULL};
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	PyObject *arg;
+	const struct libiscsi_auth_info *authinfo = NULL;
+
+	if (!PyArg_ParseTupleAndKeywords(args, kwds, "O", kwlist, &arg))
+		return NULL;
+
+	if (arg == Py_None) {
+		authinfo = NULL;
+	} else if (PyObject_IsInstance(arg, (PyObject *)
+				       &PyIscsiChapAuthInfo_Type)) {
+		PyIscsiChapAuthInfo *pyauthinfo = (PyIscsiChapAuthInfo *)arg;
+		authinfo = &pyauthinfo->info;
+	} else {
+		PyErr_SetString(PyExc_ValueError, "invalid authinfo type");
+		return NULL;
+	}
+
+	if (libiscsi_node_set_auth(context, &node->node, authinfo)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+	Py_RETURN_NONE;
+}
+
+static PyObject *PyIscsiNode_getAuth(PyObject *self)
+{
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	PyIscsiChapAuthInfo *pyauthinfo;
+	struct libiscsi_auth_info authinfo;
+
+	if (libiscsi_node_get_auth(context, &node->node, &authinfo)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+
+	switch (authinfo.method) {
+	case libiscsi_auth_chap:
+		pyauthinfo = PyObject_New(PyIscsiChapAuthInfo,
+					  &PyIscsiChapAuthInfo_Type);
+		if (!pyauthinfo)
+			return NULL;
+
+		pyauthinfo->info = authinfo;
+
+		return (PyObject *)pyauthinfo;
+
+	case libiscsi_auth_none:
+	default:
+		Py_RETURN_NONE;
+	}
+}
+
+static PyObject *PyIscsiNode_setParameter(PyObject *self, PyObject *args,
+					  PyObject *kwds)
+{
+	char *kwlist[] = {"parameter", "value", NULL};
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	const char *parameter, *value;
+
+	if (!PyArg_ParseTupleAndKeywords(args, kwds, "ss", kwlist,
+					 &parameter, &value))
+		return NULL;
+	if (check_string(parameter) || check_string(value))
+		return NULL;
+
+	if (libiscsi_node_set_parameter(context, &node->node, parameter,
+				        value)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+	Py_RETURN_NONE;
+}
+
+static PyObject *PyIscsiNode_getParameter(PyObject *self, PyObject *args,
+					  PyObject *kwds)
+{
+	char *kwlist[] = {"parameter", NULL};
+	PyIscsiNode *node = (PyIscsiNode *)self;
+	const char *parameter;
+	char value[LIBISCSI_VALUE_MAXLEN];
+
+	if (!PyArg_ParseTupleAndKeywords(args, kwds, "s", kwlist, &parameter))
+		return NULL;
+	if (check_string(parameter))
+		return NULL;
+
+	if (libiscsi_node_get_parameter(context, &node->node, parameter,
+					value)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+	return Py_BuildValue("s", value);
+}
+
+static struct PyGetSetDef PyIscsiNode_getseters[] = {
+	{"name", (getter)PyIscsiNode_get, (setter)PyIscsiNode_set,
+		"name", "name"},
+	{"tpgt", (getter)PyIscsiNode_get, (setter)PyIscsiNode_set,
+		"tpgt", "tpgt"},
+	{"address", (getter)PyIscsiNode_get, (setter)PyIscsiNode_set,
+		"address", "address"},
+	{"port", (getter)PyIscsiNode_get, (setter)PyIscsiNode_set,
+		"port", "port"},
+	{"iface", (getter)PyIscsiNode_get, (setter)PyIscsiNode_set,
+		"iface", "iface"},
+	{NULL}
+};
+
+static struct PyMethodDef  PyIscsiNode_methods[] = {
+	{"login", (PyCFunction) PyIscsiNode_login, METH_NOARGS,
+		"Log in to the node"},
+	{"logout", (PyCFunction) PyIscsiNode_logout, METH_NOARGS,
+		"Log out of the node"},
+	{"setAuth", (PyCFunction) PyIscsiNode_setAuth,
+		METH_VARARGS|METH_KEYWORDS,
+		"Set authentication information"},
+	{"getAuth", (PyCFunction) PyIscsiNode_getAuth, METH_NOARGS,
+		"Get authentication information"},
+	{"setParameter", (PyCFunction) PyIscsiNode_setParameter,
+		METH_VARARGS|METH_KEYWORDS,
+		"Set an iscsi node parameter"},
+	{"getParameter", (PyCFunction) PyIscsiNode_getParameter,
+		METH_VARARGS|METH_KEYWORDS,
+		"Get an iscsi node parameter"},
+	{NULL}
+};
+
+PyTypeObject PyIscsiNode_Type = {
+	PyObject_HEAD_INIT(NULL)
+	.tp_name = "libiscsi.node",
+	.tp_basicsize = sizeof (PyIscsiNode),
+	.tp_getset = PyIscsiNode_getseters,
+	.tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |
+		    Py_TPFLAGS_BASETYPE,
+	.tp_methods = PyIscsiNode_methods,
+	.tp_compare = (cmpfunc)PyIscsiNode_compare,
+	.tp_init = PyIscsiNode_init,
+	.tp_str = PyIscsiNode_str,
+	.tp_new = PyType_GenericNew,
+	.tp_doc = "The iscsi node contains iscsi node information.",
+};
+
+/***************************************************************************/
+
+static PyObject *pylibiscsi_discover_sendtargets(PyObject *self,
+						PyObject *args, PyObject *kwds)
+{
+	char *kwlist[] = {"address", "port", "authinfo", NULL};
+	const char *address = NULL;
+	int i, nr_found, port = 3260;
+	PyObject *authinfo_arg = NULL;
+	const struct libiscsi_auth_info *authinfo = NULL;
+	struct libiscsi_node *found_nodes;
+	PyObject* found_node_list;
+
+	if (!PyArg_ParseTupleAndKeywords(args, kwds, "s|iO",
+					kwlist, &address, &port,
+					&authinfo_arg))
+		return NULL;
+
+	if (authinfo_arg) {
+		if (PyObject_IsInstance(authinfo_arg, (PyObject *)
+					       &PyIscsiChapAuthInfo_Type)) {
+			PyIscsiChapAuthInfo *pyauthinfo =
+				(PyIscsiChapAuthInfo *)authinfo_arg;
+			authinfo = &pyauthinfo->info;
+		} else if (authinfo_arg != Py_None) {
+			PyErr_SetString(PyExc_ValueError,
+				"invalid authinfo type");
+			return NULL;
+		}
+	}
+
+	if (libiscsi_discover_sendtargets(context, address, port, authinfo,
+					  &nr_found, &found_nodes)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+
+	if (nr_found == 0)
+		Py_RETURN_NONE;
+
+	found_node_list = PyList_New(nr_found);
+	if (!found_node_list)
+		return NULL;
+
+	for(i = 0; i < nr_found; i++) {
+		PyIscsiNode *pynode;
+		
+		pynode = PyObject_New(PyIscsiNode, &PyIscsiNode_Type);
+		if (!pynode) {
+			/* This will deref already added nodes for us */
+			Py_DECREF(found_node_list);
+			return NULL;
+		}
+		pynode->node = found_nodes[i];
+		PyList_SET_ITEM(found_node_list, i, (PyObject *)pynode);
+	}
+
+	return found_node_list;	
+}
+
+static PyObject *pylibiscsi_discover_firmware(PyObject *self)
+{
+	int i, nr_found;
+	struct libiscsi_node *found_nodes;
+	PyObject* found_node_list;
+
+	if (libiscsi_discover_firmware(context, &nr_found, &found_nodes)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+
+	if (nr_found == 0)
+		Py_RETURN_NONE;
+
+	found_node_list = PyList_New(nr_found);
+	if (!found_node_list)
+		return NULL;
+
+	for(i = 0; i < nr_found; i++) {
+		PyIscsiNode *pynode;
+		
+		pynode = PyObject_New(PyIscsiNode, &PyIscsiNode_Type);
+		if (!pynode) {
+			/* This will deref already added nodes for us */
+			Py_DECREF(found_node_list);
+			return NULL;
+		}
+		pynode->node = found_nodes[i];
+		PyList_SET_ITEM(found_node_list, i, (PyObject *)pynode);
+	}
+
+	return found_node_list;	
+}
+
+static PyObject *pylibiscsi_get_firmware_initiator_name(PyObject *self)
+{
+	char initiatorname[LIBISCSI_VALUE_MAXLEN];
+
+	if (libiscsi_get_firmware_initiator_name(initiatorname)) {
+		PyErr_SetString(PyExc_IOError,
+				libiscsi_get_error_string(context));
+		return NULL;
+	}
+
+	return PyString_FromString(initiatorname);
+}
+
+static PyMethodDef pylibiscsi_functions[] = {
+	{	"discover_sendtargets",
+		(PyCFunction)pylibiscsi_discover_sendtargets,
+		METH_VARARGS|METH_KEYWORDS,
+		"Do sendtargets discovery and return a list of found nodes)"},
+	{	"discover_firmware",
+		(PyCFunction)pylibiscsi_discover_firmware, METH_NOARGS,
+		"Do firmware discovery and return a list of found nodes)"},
+	{	"get_firmware_initiator_name",
+		(PyCFunction)pylibiscsi_get_firmware_initiator_name,
+		METH_NOARGS,
+		"Get initator name (iqn) from firmware"},
+	{NULL, NULL}
+};
+
+PyMODINIT_FUNC initlibiscsi(void)
+{
+	PyObject *m;
+
+	if (!context) /* We may be called more then once */
+		context = libiscsi_init();
+	if (!context)
+		return;
+
+	if (PyType_Ready(&PyIscsiChapAuthInfo_Type) < 0)
+		return;
+
+	if (PyType_Ready(&PyIscsiNode_Type) < 0)
+		return;
+
+	m = Py_InitModule("libiscsi", pylibiscsi_functions);
+	Py_INCREF(&PyIscsiChapAuthInfo_Type);
+	PyModule_AddObject(m, "chapAuthInfo", (PyObject *) &PyIscsiChapAuthInfo_Type);
+	Py_INCREF(&PyIscsiNode_Type);
+	PyModule_AddObject(m, "node", (PyObject *) &PyIscsiNode_Type);
+}
Index: open-iscsi-2.0-873/libiscsi/setup.py
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/setup.py
@@ -0,0 +1,9 @@
+from distutils.core import setup, Extension
+
+module1 = Extension('libiscsimodule',
+                    sources = ['pylibiscsi.c'],
+                    libraries = ['iscsi'],
+                    library_dirs = ['.'])
+
+setup (name = 'PyIscsi',version = '1.0',
+       description = 'libiscsi python bindings', ext_modules = [module1])
Index: open-iscsi-2.0-873/libiscsi/tests/test_discovery_firmware.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_discovery_firmware.c
@@ -0,0 +1,53 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_node *found_nodes;
+	struct libiscsi_context *context;
+	int i, found, rc = 0;
+
+	context = libiscsi_init();
+	if (!context) {
+		fprintf(stderr, "Error initializing libiscsi\n");
+		return 1;
+	}
+
+	rc = libiscsi_discover_firmware(context, &found, &found_nodes);
+	if (rc)
+		fprintf(stderr, "Error discovering: %s\n",
+			libiscsi_get_error_string(context));
+
+	for (i = 0; i < found; i++) {
+		fprintf(stdout, "Found node: %s, tpgt: %d, portal: %s:%d\n",
+			found_nodes[i].name, found_nodes[i].tpgt,
+			found_nodes[i].address,	found_nodes[i].port);
+	}
+
+	libiscsi_cleanup(context);
+	free (found_nodes);
+
+	return rc;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_discovery_sendtargets.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_discovery_sendtargets.c
@@ -0,0 +1,60 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_node *found_nodes;
+	struct libiscsi_context *context;
+	struct libiscsi_auth_info auth_info;
+	int i, found, rc = 0;
+
+	context = libiscsi_init();
+	if (!context) {
+		fprintf(stderr, "Error initializing libiscsi\n");
+		return 1;
+	}
+
+	memset(&auth_info, 0, sizeof(auth_info));
+	auth_info.method = libiscsi_auth_chap;
+	strcpy(auth_info.chap.username, "joe");
+	strcpy(auth_info.chap.password, "secret");
+
+	rc = libiscsi_discover_sendtargets(context, "127.0.0.1", 3260,
+					   &auth_info, &found, &found_nodes);
+	if (rc)
+		fprintf(stderr, "Error discovering: %s\n",
+			libiscsi_get_error_string(context));
+
+	for (i = 0; i < found; i++) {
+		fprintf(stdout, "Found node: %s, tpgt: %d, portal: %s:%d\n",
+			found_nodes[i].name, found_nodes[i].tpgt,
+			found_nodes[i].address,	found_nodes[i].port);
+	}
+
+	libiscsi_cleanup(context);
+	free (found_nodes);
+
+	return rc;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_get_auth.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_get_auth.c
@@ -0,0 +1,70 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_node node;
+	struct libiscsi_context *context;
+	struct libiscsi_auth_info auth_info;
+	int rc = 0;
+
+	snprintf(node.name, LIBISCSI_VALUE_MAXLEN, "%s",
+		 "iqn.2009-01.com.example:testdisk");
+	node.tpgt = 1;
+	snprintf(node.address, NI_MAXHOST, "%s", "127.0.0.1");
+	node.port = 3260;
+
+	context = libiscsi_init();
+	if (!context) {
+		fprintf(stderr, "Error initializing libiscsi\n");
+		return 1;
+	}
+
+	rc = libiscsi_node_get_auth(context, &node, &auth_info);
+	if (rc) {
+		fprintf(stderr, "Error setting authinfo: %s\n",
+			libiscsi_get_error_string(context));
+		goto leave;
+	}
+
+	switch (auth_info.method) {
+		case libiscsi_auth_none:
+			printf("Method:  \"None\"\n");
+			break;
+		case libiscsi_auth_chap:
+			printf("Method:  \"CHAP\"\n");
+			printf("User:    \"%s\"\n", auth_info.chap.username);
+			printf("Pass:    \"%s\"\n", auth_info.chap.password);
+			printf("RevUser: \"%s\"\n",
+				auth_info.chap.reverse_username);
+			printf("RevPass: \"%s\"\n",
+				auth_info.chap.reverse_password);
+			break;
+	}
+leave:
+	libiscsi_cleanup(context);
+
+	return rc;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_get_initiator_name.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_get_initiator_name.c
@@ -0,0 +1,38 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	char initiatorname[LIBISCSI_VALUE_MAXLEN];
+
+	if (libiscsi_get_firmware_initiator_name(initiatorname)) {
+		fprintf(stderr, "No iscsi boot firmware found\n");
+		return 1;
+	}
+
+	printf("iqn:\t%s\n", initiatorname);
+
+	return 0;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_get_network_config.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_get_network_config.c
@@ -0,0 +1,45 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_network_config config;
+
+	if (libiscsi_get_firmware_network_config(&config)) {
+		fprintf(stderr, "No iscsi boot firmware found\n");
+		return 1;
+	}
+
+	printf("dhcp:\t%d\n", config.dhcp);
+	printf("iface:\t%s\n", config.iface_name);
+	printf("mac:\t%s\n", config.mac_address);
+	printf("ipaddr:\t%s\n", config.ip_address);
+	printf("mask:\t%s\n", config.netmask);
+	printf("gate:\t%s\n", config.gateway);
+	printf("dns1:\t%s\n", config.primary_dns);
+	printf("dns2:\t%s\n", config.secondary_dns);
+
+	return 0;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_login.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_login.c
@@ -0,0 +1,52 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_node node;
+	struct libiscsi_context *context;
+	int rc = 0;
+
+	snprintf(node.name, LIBISCSI_VALUE_MAXLEN, "%s",
+		 "iqn.2009-01.com.example:testdisk");
+	node.tpgt = 1;
+	snprintf(node.address, NI_MAXHOST, "%s", "127.0.0.1");
+	node.port = 3260;
+
+	context = libiscsi_init();
+	if (!context) {
+		fprintf(stderr, "Error initializing libiscsi\n");
+		return 1;
+	}
+
+	rc = libiscsi_node_login(context, &node);
+	if (rc)
+		fprintf(stderr, "Error logging in: %s\n",
+			libiscsi_get_error_string(context));
+
+	libiscsi_cleanup(context);
+
+	return rc;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_logout.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_logout.c
@@ -0,0 +1,51 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_node node;
+	struct libiscsi_context *context;
+	int rc = 0;
+
+	snprintf(node.name, LIBISCSI_VALUE_MAXLEN, "%s",
+		 "iqn.2009-01.com.example:testdisk");
+	node.tpgt = 1;
+	snprintf(node.address, NI_MAXHOST, "%s", "127.0.0.1");
+	node.port = 3260;
+	
+	context = libiscsi_init();
+	if (!context) {
+		fprintf(stderr, "Error initializing libiscsi\n");
+		return 1;
+	}
+
+	rc = libiscsi_node_logout(context, &node);
+	if (rc)
+		fprintf(stderr, "Error logging out: %s\n",
+			libiscsi_get_error_string(context));
+
+	libiscsi_cleanup(context);
+
+	return rc;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_params.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_params.c
@@ -0,0 +1,103 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_node node;
+	struct libiscsi_context *context;
+	char orig_value[LIBISCSI_VALUE_MAXLEN], value[LIBISCSI_VALUE_MAXLEN];
+	int rc = 0;
+
+	snprintf(node.name, LIBISCSI_VALUE_MAXLEN, "%s",
+		 "iqn.2009-01.com.example:testdisk");
+	node.tpgt = 1;
+	snprintf(node.address, NI_MAXHOST, "%s", "127.0.0.1");
+	node.port = 3260;
+
+	context = libiscsi_init();
+	if (!context) {
+		fprintf(stderr, "Error initializing libiscsi\n");
+		return 1;
+	}
+
+	rc = libiscsi_node_get_parameter(context, &node, "node.startup",
+		orig_value);
+	if (rc) {
+		fprintf(stderr, "Error getting original value: %s\n",
+			libiscsi_get_error_string(context));
+		goto leave;
+	}
+
+	rc = libiscsi_node_set_parameter(context, &node, "node.startup",
+		"automatic");
+	if (rc) {
+		fprintf(stderr, "Error setting node startup param: %s\n",
+			libiscsi_get_error_string(context));
+		goto leave;
+	}
+
+	rc = libiscsi_node_get_parameter(context, &node, "node.startup",
+		value);
+	if (rc) {
+		fprintf(stderr, "Error getting node startup param: %s\n",
+			libiscsi_get_error_string(context));
+		goto leave;
+	}
+	
+	if (strcmp(value, "automatic")) {
+		fprintf(stderr, "Error set and get values do not match!\n");
+		rc = EIO;
+		goto leave;
+	}
+
+	rc = libiscsi_node_set_parameter(context, &node, "node.startup",
+		orig_value);
+	if (rc) {
+		fprintf(stderr, "Error setting original value: %s\n",
+			libiscsi_get_error_string(context));
+		goto leave;
+	}
+
+	rc = libiscsi_node_get_parameter(context, &node, "node.startup",
+		value);
+	if (rc) {
+		fprintf(stderr, "Error re-getting original value: %s\n",
+			libiscsi_get_error_string(context));
+		goto leave;
+	}
+
+	if (strcmp(value, orig_value)) {
+		fprintf(stderr,
+			"Error set and get original values do not match!\n");
+		rc = EIO;
+		goto leave;
+	}
+
+leave:
+	libiscsi_cleanup(context);
+
+	return rc;
+}
Index: open-iscsi-2.0-873/libiscsi/tests/test_set_auth.c
===================================================================
--- /dev/null
+++ open-iscsi-2.0-873/libiscsi/tests/test_set_auth.c
@@ -0,0 +1,58 @@
+/*
+ * iSCSI Administration library
+ *
+ * Copyright (C) 2008-2009 Red Hat, Inc. All rights reserved.
+ * Copyright (C) 2008-2009 Hans de Goede <hdegoede@redhat.com>
+ * maintained by open-iscsi@googlegroups.com
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published
+ * by the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * See the file COPYING included with this distribution for more details.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "libiscsi.h"
+
+int main(void)
+{
+	struct libiscsi_node node;
+	struct libiscsi_context *context;
+	struct libiscsi_auth_info auth_info;
+	int rc = 0;
+
+	snprintf(node.name, LIBISCSI_VALUE_MAXLEN, "%s",
+		 "iqn.2009-01.com.example:testdisk");
+	node.tpgt = 1;
+	snprintf(node.address, NI_MAXHOST, "%s", "127.0.0.1");
+	node.port = 3260;
+
+	memset(&auth_info, 0, sizeof(auth_info));
+	auth_info.method = libiscsi_auth_chap;
+	strcpy(auth_info.chap.username, "joe");
+	strcpy(auth_info.chap.password, "secret");
+
+	context = libiscsi_init();
+	if (!context) {
+		fprintf(stderr, "Error initializing libiscsi\n");
+		return 1;
+	}
+
+	rc = libiscsi_node_set_auth(context, &node, &auth_info);
+	if (rc)
+		fprintf(stderr, "Error setting authinfo: %s\n",
+			libiscsi_get_error_string(context));
+
+	libiscsi_cleanup(context);
+
+	return rc;
+}
Index: open-iscsi-2.0-873/Makefile
===================================================================
--- open-iscsi-2.0-873.orig/Makefile
+++ open-iscsi-2.0-873/Makefile
@@ -32,6 +32,7 @@ user: utils/open-isns/Makefile
 	$(MAKE) -C utils/fwparam_ibft
 	$(MAKE) -C usr
 	$(MAKE) -C utils
+	$(MAKE) -C libiscsi
 	@echo
 	@echo "Compilation complete                 Output file"
 	@echo "-----------------------------------  ----------------"
@@ -56,6 +57,7 @@ kernel: force
 force: ;
 
 clean:
+	$(MAKE) -C libiscsi clean
 	$(MAKE) -C utils/sysdeps clean
 	$(MAKE) -C utils/fwparam_ibft clean
 	$(MAKE) -C utils clean
Index: open-iscsi-2.0-873/usr/discovery.c
===================================================================
--- open-iscsi-2.0-873.orig/usr/discovery.c
+++ open-iscsi-2.0-873/usr/discovery.c
@@ -36,6 +36,7 @@
 #include "types.h"
 #include "iscsi_proto.h"
 #include "initiator.h"
+#include "config.h"
 #include "log.h"
 #include "idbm.h"
 #include "iscsi_settings.h"
@@ -50,9 +51,11 @@
 #include "iscsi_timer.h"
 #include "iscsi_err.h"
 /* libisns includes */
+#ifdef ISNS_ENABLE
 #include "isns.h"
 #include "paths.h"
 #include "message.h"
+#endif
 
 #ifdef SLP_ENABLE
 #include "iscsi-slp-discovery.h"
@@ -98,6 +101,7 @@ static int request_initiator_name(void)
 	return 0;
 }
 
+#ifdef ISNS_ENABLE
 void discovery_isns_free_servername(void)
 {
 	if (isns_config.ic_server_name)
@@ -377,6 +381,7 @@ retry:
 	discovery_isns_free_servername();
 	return rc;
 }
+#endif
 
 int discovery_fw(void *data, struct iface_rec *iface,
 		 struct list_head *rec_list)
Index: open-iscsi-2.0-873/usr/idbm.c
===================================================================
--- open-iscsi-2.0-873.orig/usr/idbm.c
+++ open-iscsi-2.0-873/usr/idbm.c
@@ -1335,9 +1335,9 @@ int idbm_print_all_discovery(int info_le
  * fn should return -1 if it skipped the rec, a ISCSI_ERR error code if
  * the operation failed or 0 if fn was run successfully.
  */
-static int idbm_for_each_iface(int *found, void *data,
-				idbm_iface_op_fn *fn,
-				char *targetname, int tpgt, char *ip, int port)
+int idbm_for_each_iface(int *found, void *data,
+			idbm_iface_op_fn *fn,
+			char *targetname, int tpgt, char *ip, int port)
 {
 	DIR *iface_dirfd;
 	struct dirent *iface_dent;
Index: open-iscsi-2.0-873/usr/idbm.h
===================================================================
--- open-iscsi-2.0-873.orig/usr/idbm.h
+++ open-iscsi-2.0-873/usr/idbm.h
@@ -101,6 +101,9 @@ struct rec_op_data {
 	node_rec_t *match_rec;
 	idbm_iface_op_fn *fn;
 };
+extern int idbm_for_each_iface(int *found, void *data,
+			       idbm_iface_op_fn *fn,
+			       char *targetname, int tpgt, char *ip, int port);
 extern int idbm_for_each_portal(int *found, void *data,
 				idbm_portal_op_fn *fn, char *targetname);
 extern int idbm_for_each_node(int *found, void *data,
Index: open-iscsi-2.0-873/usr/iscsi_ipc.h
===================================================================
--- open-iscsi-2.0-873.orig/usr/iscsi_ipc.h
+++ open-iscsi-2.0-873/usr/iscsi_ipc.h
@@ -147,4 +147,6 @@ struct iscsi_ipc {
 			    uint16_t chap_tbl_idx);
 };
 
+struct iscsi_ipc *ipc;
+
 #endif /* ISCSI_IPC_H */
Index: open-iscsi-2.0-873/usr/Makefile
===================================================================
--- open-iscsi-2.0-873.orig/usr/Makefile
+++ open-iscsi-2.0-873/usr/Makefile
@@ -31,7 +31,7 @@ endif
 OPTFLAGS ?= -O2 -g
 WARNFLAGS ?= -Wall -Wstrict-prototypes
 CFLAGS += $(OPTFLAGS) $(WARNFLAGS) -I../include -I. -I../utils/open-isns \
-				-D$(OSNAME) $(IPC_CFLAGS)
+				-D$(OSNAME) $(IPC_CFLAGS) -DISNS_ENABLE
 PROGRAMS = iscsid iscsiadm iscsistart
 
 # libc compat files
