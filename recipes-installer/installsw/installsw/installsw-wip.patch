diff --git a/cur_inter.c b/cur_inter.c
index 556b614..d0cb7ef 100644
--- a/cur_inter.c
+++ b/cur_inter.c
@@ -526,18 +526,18 @@ fork_and_in_child(rvalp)
 }
 
 /*
-* cur_rpm
+* cur_package
 *	Add a package to the list of RPMs to install, or
 *	Close the file descriptor to the list of RPMs, or
 *	Install all the RPMs
 */
-#define RPM_ADD			0
-#define RPM_PRE_INSTALL		1
-#define RPM_INSTALL		2
-#define RPM_POST_INSTALL	3
+#define PKG_ADD			0
+#define PKG_PRE_INSTALL		1
+#define PKG_INSTALL		2
+#define PKG_POST_INSTALL	3
 
 static int
-cur_rpm(how, pkg)
+cur_package(how, pkg)
 	int how;
 	PKG *pkg;
 {
@@ -546,29 +546,45 @@ cur_rpm(how, pkg)
 	char *name, *cp;
 
 	switch (how) {
-	case RPM_ADD:
-		if (lfp == NULL && (lfp = fopen(_PATH_TMP_RPMS, "w")) == NULL) {
+	case PKG_ADD:
+		if (lfp == NULL && (lfp = fopen(_PATH_TMP_PKGS, "w")) == NULL) {
 			rval = 1;
 			break;
 		}
+#ifdef ENABLE_RPM
 		fprintf(lfp, "%s/RPMS/%s.rpm\n", device, pkg->name);
+#endif
+#ifdef ENABLE_YP
+		fprintf(lfp, "%s\n", pkg->sentinel);
+#endif
 		break;
 
-	case RPM_PRE_INSTALL:
+	case PKG_PRE_INSTALL:
 		fflush(lfp);
 		fclose(lfp);
 		lfp = NULL;
 		break;
 
-	case RPM_INSTALL:
+	case PKG_INSTALL:
+#ifdef ENABLE_RPM
 		cp = strrchr(rpmcmd, '/');
 		name = cp ? ++cp : rpmcmd;
 
 		if (fork_and_in_child(&rval)) {
 			execl(rpmcmd, name, RPM_ARGS_EXECL, "--excludedocs",
-			    "--root", rootdir, "-Uvh", _PATH_TMP_RPMS, NULL);
+			    "--root", rootdir, "-Uvh", _PATH_TMP_PKGS, NULL);
 			exit(1);
 		}
+#endif
+#ifdef ENABLE_YP
+		cp = strrchr(ypcmd, '/');
+		name = cp ? ++cp : ypcmd;
+
+		if (fork_and_in_child(&rval)) {
+			execl(ypcmd, name, rootdir, NULL);
+			exit(1);
+		}
+#endif
 		if (rval || !prelink)
 			break;
 
@@ -599,8 +615,8 @@ cur_rpm(how, pkg)
 		 */
 		break;
 
-	case RPM_POST_INSTALL:
-		(void)unlink(_PATH_TMP_RPMS);
+	case PKG_POST_INSTALL:
+		/* (void)unlink(_PATH_TMP_PKGS); */
 		break;
 	}
 	return(rval);
@@ -619,19 +635,18 @@ cur_install(pkghp, grphp)
 	sigset_t set;
 	size_t row;
 	int i, rval;
-	PKG *last_rpm = NULL;
-
+	PKG *last_pkg = NULL;
 	/*
 	 * Run the before installation scripts.  The select flag is toggled
 	 * as packages are installed, so set the script flag first.
 	 *
-	 * Also, keep track of the last package of type T_RPM.
+	 * Also, keep track of the last package of type T_RPM or T_YP.
 	 */
 	for (pkg = TAILQ_FIRST(pkghp); pkg != NULL; pkg = TAILQ_NEXT(pkg, q)) {
 		if (pkg->selected) {
 			pkg->script = 1;
-			if (pkg->type == T_RPM)
-				last_rpm = pkg;
+			if (pkg->type == T_RPM || pkg->type == T_YP)
+				last_pkg = pkg;
 		}
 	}
 	if (cur_iscript(pkghp, SCRIPT_BEGIN, "pre-install", 1))
@@ -734,13 +749,13 @@ cur_install(pkghp, grphp)
 		}
 		/*
 		 * When we hit the last package that is of
-		 * type T_RPM, do the mass RPM installation.
-		 * This allows the packagelist to have non T_RPM
+		 * type T_RPM or T_YP, do the mass package installation.
+		 * This allows the packagelist to have non T_RPM or T_YP
 		 * items at the end of the list, to be installed
-		 * after all the T_RPM packages.
+		 * after all the packages.
 		 */
-		if (pkg == last_rpm) {
-			last_rpm = NULL;
+		if (pkg == last_pkg) {
+			last_pkg = NULL;
 			if (cur_exec(pkghp, grphp, NULL)) {
 				rval = 1;
 				break;
@@ -749,11 +764,11 @@ cur_install(pkghp, grphp)
 	}
 
 	/*
-	 * This shouldn't happen, but if last_rpm is set, it
-	 * means we didn't do the mass RPM package install, so
+	 * This shouldn't happen, but if last_pkg is set, it
+	 * means we didn't do the mass package install, so
 	 * do it now.
 	 */
-	if (rval == 0 && last_rpm && cur_exec(pkghp, grphp, NULL))
+	if (rval == 0 && last_pkg && cur_exec(pkghp, grphp, NULL))
 		rval = 1;
 
 	if (rval == 0) {
@@ -767,7 +782,7 @@ cur_install(pkghp, grphp)
 		cur_scroll();
 		standout();
 		mvprintw(cur_row, pc_scr_off,
-"Installation was UNSUCCESSFUL for a package; press any key to continue:");
+"Installation was UNSUCCESSFUL (ret = %d) for a package; press any key to continue:", rval);
 		standend();
 		refresh();
 		(void)getchar();
@@ -825,8 +840,8 @@ cur_exec(pkghp, grphp, pkg)
 	 * the list of all RPMs to install.  If pkg is NULL, it
 	 * means to install all the RPMs.
 	 */
-	if (pkg && pkg->type == T_RPM) {
-		rval = cur_rpm(RPM_ADD, pkg);
+	if (pkg && (pkg->type == T_RPM || pkg->type == T_YP)) {
+		rval = cur_package(PKG_ADD, pkg);
 		goto defer_install;
 	}
 	/*
@@ -843,10 +858,10 @@ cur_exec(pkghp, grphp, pkg)
 
 	/*
 	 * Before installing the RPMs, we need to close the file descriptor
-	 * we were using to write to _PATH_TMP_RPMS
+	 * we were using to write to _PATH_TMP_PKGS
 	 */
 	if (pkg == NULL)
-		(void)cur_rpm(RPM_PRE_INSTALL, NULL);
+		(void)cur_package(PKG_PRE_INSTALL, NULL);
 
 	switch (pid = fork()) {
 	case -1:				/* Error. */
@@ -869,7 +884,7 @@ cur_exec(pkghp, grphp, pkg)
 
 		/* Install packages. */
 		if (pkg == NULL)	/* Install all the RPMs */
-			rval = cur_rpm(RPM_INSTALL, NULL);
+			rval = cur_package(PKG_INSTALL, NULL);
 		else
 			rval = install(pkg, rootdir, 1);
 
@@ -967,7 +982,7 @@ cur_exec(pkghp, grphp, pkg)
 
 	/* We're done installing RPMs, do the post install cleanup */
 	if (pkg == NULL)
-		(void)cur_rpm(RPM_POST_INSTALL, NULL);
+		(void)cur_package(PKG_POST_INSTALL, NULL);
 
 defer_install:
 	/* If interactive, turn off the package highlight in the menu. */
@@ -1438,6 +1453,18 @@ cur_info(pkghp)
 			}
 			pclose(fp);
 		}
+	} else if (PKG_TYPE_IS_YP(pkg->type)) {
+		(void)snprintf(buf, sizeof(buf),
+		    "%s/%s", device, pkg->name);
+		addnstr(buf, strlen(buf));
+		if ((fp = fopen(buf, "r")) != NULL) {
+			clear();
+			for (row = 0; (lp = fgetln(fp, &len)) != NULL; ++row) {
+				(void)move(row, 0);
+				addnstr(lp, len - 1);
+			}
+			fclose(fp);
+		}
 	} else if (spkg != NULL) {
 		(void)snprintf(buf, sizeof(buf),
 		    "%s/%s/%s", spkg->root, pkg->name, SCRIPT_INFO);
diff --git a/installsw.c b/installsw.c
index 4f7f1fb..fe43fef 100644
--- a/installsw.c
+++ b/installsw.c
@@ -37,7 +37,12 @@ char   *device		= MEDIA_MOUNTPT; /* media mount */
 char   *rootdir		= DEF_ROOT;	/* Root directory. */
 char   *remote_host;			/* Remote host. */
 char   *remote_user;			/* Remote user. */
+#ifdef ENABLE_RPM
 char   *rpmcmd = _PATH_RPM;
+#endif
+#ifdef ENABLE_YP
+char   *ypcmd = _PATH_YP_INSTALL;
+#endif
 int	prelink;
 char   *prelinkcmd = _PATH_PRELINK;
 
@@ -47,7 +52,12 @@ static void	get_packages __P((PKGH *, GRPH *));
 static void	get_scripts __P((PKGH *));
 static void	s_mark __P((PKGH *));
 static void	usage __P((void));
+#ifdef ENABLE_RPM
 static int	rpm_installed __P((PKG *));
+#endif
+#ifdef ENABLE_YP
+static int	yp_installed __P((PKG *));
+#endif
 static void	grp_sort __P((GRPH *, int));
 
 /*
@@ -121,11 +131,13 @@ main(argc, argv)
 				err(1, prelinkcmd);
 			break;
 
+#ifdef ENABLE_RPM
 		case 'R':
 			rpmcmd = optarg;
 			if (access(rpmcmd, X_OK) < 0)
 				err(1, rpmcmd);
 			break;
+#endif
 
 		case 's':
 			if (optarg[1] != '\0' ||
@@ -455,7 +467,7 @@ grp_sort(grphp, ngrps)
 	free(grplist);
 }
 
-
+#ifdef ENABLE_RPM
 static int
 rpm_installed(pkg)
 	PKG *pkg;
@@ -512,6 +524,66 @@ rpm_installed(pkg)
 	}
 	return (0);
 }
+#endif
+
+#ifdef ENABLE_YP
+static int
+yp_installed(pkg)
+	PKG *pkg;
+{
+	static int first_time = 1;
+	static char **installed = NULL;
+	static int installed_len = 0;
+	char *cp, *cp2, **cpp;
+
+	if (first_time) {
+		char buf[MAXPATHLEN];
+		FILE *fp;
+		size_t len;
+
+		first_time = 0;
+		if ((installed = malloc(128 * sizeof(*installed))) == NULL)
+			return 0;
+		installed_len = 128;
+
+		snprintf(buf, sizeof(buf), 
+		    "bb_query %s/build %s/pkgdata %s/feed %s",
+		    device, device, device, rootdir);
+		if ((fp = popen(buf, "r")) == NULL) {
+			free(installed);
+			installed_len = 0;
+			return 0;
+		}
+
+		cpp = installed;
+		while ((cp = fgetln(fp, &len)) != NULL) {
+			if ((cp2 = strchr(cp, '\n')) != NULL)
+				*cp2 = '\0';
+			*cpp++ = strdup(cp);
+			if (cpp >= installed + installed_len) {
+				installed = realloc(installed,
+				    (installed_len + 128) * sizeof(*installed));
+				if (installed == NULL) {
+					installed_len = 0;
+					return (0);
+				}
+				cpp = installed + installed_len;
+				installed_len += 128;
+			}
+		}
+		*cpp++ = NULL;
+	}
+
+	if (installed != NULL) {
+		for (cpp = installed; *cpp; ++cpp) {
+			if (strcmp(pkg->sentinel, *cpp) == 0) {
+				return (1);
+			}
+		}
+	}
+	return (0);
+}
+#endif
 
 /*
  * chk_exist --
@@ -544,9 +616,17 @@ chk_exist(pkghp)
 		 * If the log entry is then found, the update bit should be
 		 * cleared.
 		 */
+#ifdef ENABLE_RPM
 		if (PKG_TYPE_IS_RPM(pkg->type))
 			pkg->present = rpm_installed(pkg);
-		else
+		else 
+#endif
+#ifdef ENABLE_YP
+		if (PKG_TYPE_IS_YP(pkg->type) && yp_installed(pkg)) {
+			pkg->present = 1;
+			pkg->selected = 1;
+		} else
+#endif
 			pkg->present = lstat(add, &sb) == 0;
 		pkg->previous = pkg->update = pkg->present;
 	}
@@ -557,7 +637,7 @@ chk_exist(pkghp)
 	/* N**2, but probably not worth fixing. */
 	for (pkg = pkghp->tqh_first; pkg != NULL; pkg = pkg->q.tqe_next) {
 		/* For RPMs, we trust the rpm manager */
-		if (PKG_TYPE_IS_RPM(pkg->type))
+		if (PKG_TYPE_IS_RPM(pkg->type) || PKG_TYPE_IS_YP(pkg->type))
 			continue;
 		/*
 		 * If sentinel not present, the log message isn't sufficient
@@ -790,6 +870,9 @@ install(pkg, root, userpackage)
 		case T_RPM_FORCE:
 			tail = ".rpm";
 			break;
+		case T_YP:
+			tail = "";
+			break;
 		default:
 			abort();
 		}
@@ -920,8 +1003,14 @@ static void
 usage()
 {
 	(void)fprintf(stderr, "usage: installsw [-DELU] [-c device] "
-	    "[-d root_dir] [-R rpm_cmd]\n"
+	    "[-d root_dir]"
+#if ENABLED_RPM
+	    "[-R rpm_cmd]"
+#endif
+	    "\n"
+#if 0
 	    "\t[-h rhost [-l ruser]] "
+#endif
 	    "[-s d | o | r]\n");
 	exit(1);
 }
diff --git a/installsw.h b/installsw.h
index e12eaf8..67e9ef3 100644
--- a/installsw.h
+++ b/installsw.h
@@ -8,7 +8,7 @@
 
 #define F_NOFILE	'X'
 
-#define PACKAGEDIR	"RPMS"
+#define PACKAGEDIR	"installsw"
 #define PACKAGEFILE	"PACKAGES"
 #define	SCRIPTFILE	"INSTALLSW-SCRIPTS"
 
@@ -59,11 +59,22 @@ typedef struct _pkg {
 #define T_RPM		'R'
 #define T_RPM_NODEPS	'r'
 #define T_RPM_FORCE	'f'
-#define PKG_TYPE_IS_RPM(x)	((x) == T_RPM || (x) == T_RPM_NODEPS || \
+#ifdef ENABLE_RPM
+ #define PKG_TYPE_IS_RPM(x)	((x) == T_RPM || (x) == T_RPM_NODEPS || \
 				 (x) == T_RPM_FORCE)
+#else
+ #define PKG_TYPE_IS_RPM(x)	0
+#endif
+#define T_YP		'Y'
+#ifdef ENABLE_YP
+ #define PKG_TYPE_IS_YP(x)		(x) == T_YP
+#else
+ #define PKG_TYPE_IS_YP(x)		0
+#endif
 #define	PKG_TYPE_IS_VALID(x)	((x) == T_COMPRESSED || (x) == T_GZIPPED || \
 				 (x) == T_TGZ || (x) == T_BZIP || \
-				 (x) == T_NORMAL || PKG_TYPE_IS_RPM(x))
+				 (x) == T_NORMAL || PKG_TYPE_IS_RPM(x) || \
+				 PKG_TYPE_IS_YP(x))
 	int  type;	/* T_ flags. */
 
 	char *desc;	/* nice printable name of the package */
@@ -98,6 +109,7 @@ extern int	express;		/* If doing an express install. */
 extern char    *remote_host;		/* Remote host. */
 extern char    *remote_user;		/* Remote user. */
 extern char    *rpmcmd;			/* path to rpm command */
+extern char    *ypcmd;			/* path to yp_install command */
 
 typedef enum { L_NONE=0, L_LOCAL, L_REMOTE } loc_t;
 extern loc_t location;
diff --git a/pathnames.h b/pathnames.h
index c7b99f8..1085d7d 100644
--- a/pathnames.h
+++ b/pathnames.h
@@ -26,7 +26,8 @@
 #define	_PATH_UNCOMPRESS	"/usr/bin/zcat"
 #endif
 #define	_PATH_UNZIP		"/usr/bin/gzcat"
-#define _PATH_RPM		"/bin/rpm"
-#define _PATH_TMP_RPMS		"/tmp/rpm_install"
+#define _PATH_RPM		"/usr/bin/rpm"
+#define _PATH_YP_INSTALL	"/opt/installer/installsw/yp_install"
+#define _PATH_TMP_PKGS		"/tmp/pkg_install"
 #define _PATH_PRELINK		"/usr/sbin/prelink"
 #define _PATH_PRELINK_ERRS	"/prelink_errs"
diff --git a/util.c b/util.c
index 420dec1..f2edf73 100644
--- a/util.c
+++ b/util.c
@@ -90,6 +90,15 @@ build_extract_command(pkg, pkgname, rpp, silent)
 		goto done;
 	}
 
+	if (PKG_TYPE_IS_YP(pkg->type)) {
+		rempart[0] = '\0';
+		p = locpart;
+		p += sprintf(p,
+		    "bb_install %s/build %s/pkgdata %s/feed %s rootfs",
+		    device, device, device, rootdir);
+		goto done;
+	}
+
 	if (location == L_REMOTE) {
 		(void)snprintf(rempart, sizeof(rempart),
 		    "%s bs=10k if=%s", _PATH_DD, hide_meta(pkgname));
