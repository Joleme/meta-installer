wr-installer
============

This layer provides a target-based installer for Wind River Linux. It requires
most of the layers that Wind River Linux provides.


Dependencies
------------
This layer depends on the Wind River Linux version of bitbake, oe-core,
meta-filesystems, meta-gnome, and wr-base layer.


Maintenance
-----------
This layer is maintained by Wind River Systems, Inc.
Contact <support@windriver.com> or your support representative for more
information on submitting changes.


Building the target installer
-----------------------------
1. Summary
   The target installer is enabled by passing "--enable-rootfs=wr-installer"
   to configure. A second option "--with-installer-target-build=<path>"
   is used to specify the path to the build directory that will supply RPMs
   to be installed on the target.  If the path is an .ext2, .ext3, or ext4
   image file, then the installer will copy this image to the target after
   the disk has been partitioned and formatted.

2. Two main use cases
   2.1 Installer image with ext2, ext3 or ext4 image from the target
       build to be copied to local disk.

   2.2 Installer image with RPMs from the target build to be installed
       to local disk.

   Note: Each option requires two builds, one is for the target build,
         the other one is for the installer itself. The build and installer
         board (BSP) configuration should be the same.

3. Examples for the use cases
   3.1 Target installer with the image
       3.1.1 Create and build the target image in project_1.
             The output image(ext3) will be used by project_2 to install
             on the target.

             Note: The installer-support template is required for project_1.

             $ configure --enable-board=intel-x86-64 \
                 --enable-kernel=standard \
                 --enable-rootfs=glibc-std+installer-support \
                 --enable-bootimage=ext3
             $ make all

       3.2.2 Create and build the installer image in project_2.
             Use the configure option --with-installer-target-build to
             point to the ext3 image from the previous step:
             $ configure --enable-board=intel-x86-64 \
                 --enable-kernel=standard --enable-rootfs=wr-installer \
                 --enable-bootimage=iso --with-installer-target-build=\
                    <project_1>/export/intel-x86-64-glibc-std-standard-dist.ext3
              $ make all

   3.2 Target installer with RPMs
       3.2.1 Create and build target RPMs in project_1.
             The output RPMs will be used by project_2 to install on
             the target.

             Note: The installer-support template is required for project_1.

             $ configure --enable-board=intel-x86-64 \
                    --enable-kernel=standard
                    --enable-rootfs=glibc-std+installer-support
             $ make all

       3.3.2 Create and build the installer image in project_2.
             Use the configure option --with-installer-target-build to point to
             root directory of project_1:

             $ configure --enable-board=intel-x86-64 \
					--enable-kernel=standard --enable-rootfs=wr-installer \
					--enable-bootimage=iso --with-installer-target-build=<project_1Dir>
             $ make all

4. Install
   4.1 Burn the output ISO to a DVD or dd it to a USB disk, and use it to
       boot the target board and start the install.

   4.2 Use qemu for testing
       Create the qemu disk:
       $ host-cross/usr/bin/qemu-img create -f qcow hd0.vdisk 5000M

       Start qemu with installer image:
       $ make start-target \
         TOPTS="-m 2048 -cd export/intel-x86-64-installer-standard-dist.iso \
         -no-kernel -disk hd0.vdisk -gc" EX_TARGET_QEMU_OPTS="-vga vmware \
         -show-cursor -usb"

       Add "-vnc :4" to EX_TARGET_QEMU_OPTS to start a VNC capable session.
       Add "-usbdevice wacom-tablet" to EX_TARGET_QEMU_OPTS to correct mouse
       pointer position, it works with the Linux 3.14, but does not work with
       Linux 3.17.

   4.3 Use virtualbox for testing
       4.3.1 Prepare virtualbox
             Take Ubuntu 14.04 for example, the virtualbox is 4.3.10
             sudo apt-get install virtualbox

       4.3.2 Create virtual machine
             'New'-> Name:***
                     Type:Linux
                     Version:Linux 2.6/3.x(64 bit)
             'Next'-> Memory size
             'Next'-> Hard drive:create a virtual hard drive now
             'Create'-> VDI(Virtualbox Disk Image)
             'Next'-> Dynamically allocated
             'Next'-> File location and size

       4.3.3 Add ISO storage to virtual machine
             Select newly created virtual machine
             'Setting'-> 'Storage'-> 'Controller:IDE'->
             'Empty'->'CD/DVD Drive: IDE Primary Master'->
             'Choose a virtual CD/DVD disk file'->
             'export/intel-x86-64-installer-standard-dist.iso'

       4.3.4 Config net for virtual machine
             Select newly created virtual machine
             'Setting'-> 'Network'-> Attached to: Bridged Adapter
                                     Name: eth0

       4.3.5 Add serial port to virtual machine
             Select newly created virtual machine
             'Setting'-> 'Serial Ports'-> 'Port 1'->
             'Enable Serial Port'-> Port Number: COM1
                                    Port Mode: Host Pipe
                                    Create Pipe
                                    Port/File Path: /tmp/pipe

       4.3.6 Use minicom to connect virtual machine's serial port
             sudo minicom -s
             'Serial port setup'->
             'A -    Serial Device      : unix#/tmp/pipe'->
             'Exit'

       4.3.7 Start virtual machine
             Select newly created virtual machine-> 'Start'

             After the installation finished, delete ISO storage and
             start virtual machine again to check the installed target.

   4.4 Need 1G memory size at least
       While starting qemu/virtualbox/vmware for testing, please make
       sure virtual machine has 1G memory at least.

5. Use custom installer.conf
   The second build can use installer.conf to help speed up the build
   process when package based installs, the user can set WRL_INSTALLER_CONF
   in the conf file, for example:

   edit <installer_build_dir>/bitbake_build/conf/local.conf
   WRL_INSTALLER_CONF = "/my/installer.conf"

   You can customize the contents of installer.conf when needed, for example,
   add packages that you will like to install, but if you do, you must ensure
   that the added packages are in the first build (project_1).

6. Perform the kickstart installation
   The installer can support kickstart installs. To do this, use the ks file
   from /root/anaconda-ks.cfg after the installation and edit it for later
   installs. You can specify the ks file by setting KICKSTART_FILE in the conf
   file, for example:

   KICKSTART_FILE = "/my/anaconda-ks.cfg"

   Then the second build will take it and start the kickstart installs
   by default when you start the target with installer image.

7. About Grub version
   The current installer only supports grub 2.

8. Upgrade an existed OS rather than fresh install
   Note: Only the installer which contains the RPMs can do the upgrade, you
         can't use the installer which contains the image to upgrade an
         existed OS.

   Note: The previous build and current build must use the same PRSever,
         otherwise you can't do the upgrade, which means that the previous
         project_1 and the current project_1 must use the same PRSever.
         Refer to the Wind River Linux User's Guide on how to setup the PRSever.

   Note: You can only upgrade the same rootfs, for example, upgrade the old
         glibc-std to new glibc-std, otherwise the upgrade may fail.

   To perform an upgrade, boot the target machine with the new ISO, select
   "Upgrade Existing Installation" rather than "Fresh Installation", then the
   existed OS will be upgraded.

9. Put multiple target builds into one installer image
   9.1 Create and build multiple target build projects.
       Refer to section 3.1.1 or 3.2.1 on how to configure and build each
       target project. In this example, the projects are named target_build1,
       target_build2 and target_build3.

   9.2 Use the configure option --with-installer-target-build to point to
       "<target_build1>,<target_build2>,<target_build3>", the comma(,)
       is the separator:
       $ configure --enable-board=intel-x86-64 \
            --enable-kernel=standard --enable-rootfs=wr-installer \
            --enable-bootimage=iso \
            --with-installer-target-build=\
            <target_build1>,<target_build2>,<target_build3>

       $ make all

       Then the installer image will contain all target builds specified,
       including target_build1, target_build2 and target_build3.

       When you boot the installer image, you will get a selection menu:
       NOTE: target_buildX is the basename of project

       =============== Found the following products ===============
       1) DISTRO1    target_build1    DISTRO_NAME1    DISTRO_VERION1
       2) DISTRO2    target_build2    DISTRO_NAME2    DISTRO_VERION2
       3) DISTRO3    target_build3    DISTRO_NAME3    DISTRO_VERION3

       Please enter your choice (0 to quit):

       NOTE: You need to use a proper name for the target build project
             since its basename will be used in the selection menus.

       NOTE: The number of the entries in WRL_INSTALLER_CONF or
             KICKSTART_FILE must be the same as the number of target build
             projects.
             For example, if you want to use WRL_INSTALLER_CONF or
             KICKSTART_FILE for target_build1, target_build2 and
             target_build3, set each of the three in the conf file.

             WRL_INSTALLER_CONF = "/my/target1.conf /my/target2.conf \
                                    /my/target3.conf"
             KICKSTART_FILE = "/my/target1.ks /my/target2.ks \
                               /my/target3.ks"

             Then target_build1 will use /my/target1.conf and /my/target1.ks,
             target_build2 and target_build3 will work similarly.

       NOTE: You must use ISO level 3 if the ISO size is larger then 4 GB, add
             the following line into your local.conf
             (bitbake_build/conf/local.conf) file:
             MKISOFS_OPTIONS_append = " -iso-level 3"

10. PXE
    10.1 Preparation
         Refer "Wind River Linux USER GUIDE 6"
         - About Configuring PXE, P422
         - Configuring PXE, P424
         - Configuring DHCP, P427
         - Configuring DHCP for PXE, P428
         - Configuring NFS, P430
         - Configuring TFTP, P431

         The PXELinux Boot Loader File pxelinux.0 located in syslinux package,
         you could directly copy it to the tftp download dir.

         Copy kernel (bzImage) to tftp download dir. In ISO, it named vmlinuz.

    10.2 initrd boot
         Use recipe wrlinux-image-installer-initramfs to support initrd boot,
         please copy initramfs (wrlinux-image-installer-initramfs-intel-x86-64.cpio.gz)
         to tftp download dir.

         We must add param "LABEL=initrd-install" to PXE config file.
         There is an example in examples/pxe/pxelinux.cfg/default.initramfs

    10.3 initrd boot with kickstart
         Based on 10.2 initrd boot, we should prepare a kickstart file on
         web server, and add param "ks=http://webserver_ip/anaconda-ks.cfg"
         to PXE config file.
         There is an example in examples/pxe/pxelinux.cfg/default.initramfs_ks

    10.4 nfs boot
         About PXE config file, there is an example in
         examples/pxe/pxelinux.cfg/default.nfs

11. How to create Large Disk (>2TB) on X86 platform
    11.1 On X86 platform, for small disk(<2TB), anaconda create msdos
         partitioned disk by default; if larger than that, it automatically
         creates GPT partitioned disk; but it has risks on some hosts(Such as
         Lenovo systems), if you do not want to create GPT disklabels on
         large disk(>2TB), it provides a boot option 'nogpt', but only 2TB
         used.

    11.2 While you use kickstart to do the installation on large disk, as there
         must be a biosboot partition for the bootloader to be installed
         successfully onto a disk that contains a GPT/GUID partition table,
         which includes disks initialized by anaconda. This partition may be
         created with the kickstart option 'part biosboot --fstype=biosboot
         --size=1 --ondisk=sda'. However, in the case that a disk has an
         existing biosboot partition, adding a "part biosboot" option is
         unnecessary.

12. How to authenticate while downloading kickstart from web server
    12.1 We add boot options 'ksuser' and 'kspasswd'(listed in /proc/cmdline)
         to support authentication while downloading kickstart from web server.

    12.2 If authentication failed, it populates a prompt page to give
         customer another chance to input username/password.

    12.3 Currently, we support basic/digest authentication, which decided by
         your web server.

13. How to add the http repository mirror list
    1. Create the mirror list file, the format is the same as the output of
    invoking "smart channel --show", you should make sure the channels/
    repositories listed in the file are correct:
    ...
    [qemux86_64]
    type = rpm-md
    priority = 55
    baseurl = http://10.0.2.2/feeds/rpm/qemux86_64

    [x86_64]
    type = rpm-md
    priority = 50
    baseurl = http://10.0.2.2/feeds/rpm/x86_64
    ...

    2. Next, place the mirror list file on the web server.

    3. When starting anaconda, choose to add an http repository, input the URL
       of the mirror list, be sure to select the 'URL is a mirror list' checkbox.
       Then click the 'ok' button to add the mirror list.

14 PXE with UEFI
    The main difference between UEFI and non-UEFI on PXE is for
    non-UEFI we use pxelinux.0 which provided by syslinux package
    as the PXELinux Boot Loader File; but for UEFI, we have to
    invoke script grub-mkstandalone which provided by grub-efi
    to generate the PXELinux Boot Loader File. The following
    introduces how to generate:

    1. Generate in tftp download dir
    1.1 Copy kernel and initramfs to tftp download dir
    $ cp export/images/bzImage /srv/tftpboot
    $ cp export/images/wrlinux-image-installer-initramfs-intel-x86-64.cpio.gz /srv/tftpboot

    1.2 Creation of a netboot grub config file
    $ cd /srv/tftpboot
    $ mkdir -p boot/grub
    $ vi boot/grub/grub.cfg
    ----start----
    menuentry 'boot serial console'{
        linux /bzImage LABEL=initrd-install ks=http://128.224.162.194/anaconda-ks.cfg console=ttyS0,115200
        initrd /wrlinux-image-installer-initramfs-intel-x86-64.cpio.gz
    }
    ----end----

    1.3 Create a standalone (static) efi image which containing an embedded
        configuration file, required modules, kernel, initramfs. The
        grub-mkstandalone and image modules were provided by grub-2.00 which
        located in bitbake_build/tmp/work/core2-64-wrs-linux/grub-efi/2.00-r2.fix0/grub-2.00/

    $ cd /srv/tftpboot

    $ PATH_TO_PROJECT/bitbake_build/tmp/work/core2-64-wrs-linux/grub-efi/2.00-r2.fix0/grub-2.00/grub-mkstandalone \
         -d PATH_TO_PROJECT/bitbake_build/tmp/work/core2-64-wrs-linux/grub-efi/2.00-r2.fix0/grub-2.00/grub-core/ \
         --modules="boot linux ext2 fat serial part_msdos part_gpt normal efi_gop iso9660 search tftp net http" \
         -O x86_64-efi --output=boot/bootx64-pxe.efi \
          boot/grub/grub.cfg bzImage wrlinux-image-installer-initramfs-intel-x86-64.cpio.gz

    The 'bootx64-pxe.efi' in /srv/tftpboot/boot is the standalone (static) efi image.

    2. Generate in host (2nd) build project dir
    2.1 Config PXE_UEFI_GRUB_CONF to add customer's grub config file
    $ cd PATH_TO_PROJECT
    $ vim local.conf
    ----start----
    PXE_UEFI_GRUB_CONF = "/srv/tftpboot/boot/grub/grub.cfg"
    ----end----
    If not edit PXE_UEFI_GRUB_CONF, there is a default grub.cfg
    in wr-installer/recipes-bsp/grub/files/

    2.2 Execute grub-efi's mkpxeimage task
    $ make grub-efi.mkpxeimage
    We should invoke the task after all image built(make fs/all)

    2.3 Copy generated bootx64-pxe.efi to tftp download dir
    $ cp PATH_TO_PROJECT/export/images/bootx64-pxe.efi /srv/tftpboot/boot

    3. Update the DHCP server config
    $ vi /etc/dhcp/dhcpd.conf
    ----start----
    option space PXE;
    option PXE.mtftp-ip    code 1 = ip-address;
    option PXE.mtftp-cport code 2 = unsigned integer 16;
    option PXE.mtftp-sport code 3 = unsigned integer 16;
    option PXE.mtftp-tmout code 4 = unsigned integer 8;
    option PXE.mtftp-delay code 5 = unsigned integer 8;
    option arch code 93 = unsigned integer 16; # RFC4578

    subnet 128.224.162.0 netmask 255.255.255.0 {
        range 128.224.162.195 128.224.162.200;
        option routers 128.224.162.194;

        class "pxeclients" {
            match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
            next-server 128.224.162.194;
            if option arch = 00:06 {
                filename "bootia32.efi";
            } else if option arch = 00:07 {
                filename "boot/bootx64-pxe.efi";
            } else {
                filename "pxelinux.0";
            }
        }
    }
    ----end----

    4. Restart dhcpd and go start PXE UEFI installation.

15 Download file from http/ftp server to target image
    Add key in kickstart to support downloading file from http/ftp
    server to target image:
    'download --dest=[file://dir/filename|/dir/filename] --src=[http url| ftp url]'

    Here is the example in kickstart file:
    ---start---
    download --dest=/etc/rpm/keys/0x100001 --src=http://128.224.162.159/testkey
    download --dest=file://etc/rpm/keys/0x100002 --src=http://128.224.162.159/testkey2
    ---end---

    The file be download to target image (/mnt/image/****). For host image,
    we could make use of "%pre" section with invoking shell to do that)

16 How to create RPM metadata in build
   make package-index

   or

   make bbs
   bitbake package-index

   There are multiple repodata in deploy dir:
   $ find export/RPMS/ -name repodata
   export/RPMS/all/repodata
   export/RPMS/corei7_64/repodata
   export/RPMS/intel_x86_64/repodata

License
-------
Copyright (C) 2013-2014 Wind River Systems, Inc.

Source code included in the tree for individual recipes is under the LICENSE
stated in the associated recipe (.bb file) unless otherwise stated.

The metadata is under the following license unless otherwise stated.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
